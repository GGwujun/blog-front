<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>19 | 热点问题答疑（二）：基础模块问题答疑 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/ios开发高手课/02.基础篇/19" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础</span><span>算法<ul><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackchain">webpackchain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>移动端开发<ul><li><a href="/blog/android开发高手课">android开发高手课</a></li><li><a aria-current="page" class="active" href="/blog/ios开发高手课">ios开发高手课</a></li></ul></span><span>软件测试</span><span>产品与用户体验<ul><li><a href="/blog/视觉笔记入门课">视觉笔记入门课</a></li></ul></span><span>面试</span><span>杂谈<ul><li><a href="/blog/git实战手册">git实战手册</a></li><li><a href="/blog/nodejs">nodejs</a></li><li><a href="/blog/reactjs">reactjs</a></li><li><a href="/blog/ui设计">ui设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础</li><li>算法<ul><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackchain">webpackchain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>移动端开发<ul><li><a href="/blog/android开发高手课">android开发高手课</a></li><li><a aria-current="page" class="active" href="/blog/ios开发高手课">ios开发高手课</a></li></ul></li><li>软件测试</li><li>产品与用户体验<ul><li><a href="/blog/视觉笔记入门课">视觉笔记入门课</a></li></ul></li><li>面试</li><li>杂谈<ul><li><a href="/blog/git实战手册">git实战手册</a></li><li><a href="/blog/nodejs">nodejs</a></li><li><a href="/blog/reactjs">reactjs</a></li><li><a href="/blog/ui设计">ui设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/ios开发高手课">ios开发高手课</a></li><li><a href="/blog/ios开发高手课/01.开篇词">01.开篇词</a><ul><li><a href="/blog/ios开发高手课/01.开篇词/01"><span>开篇词 | 锚定一个点，然后在这个点上深耕</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/ios开发高手课/02.基础篇">02.基础篇</a><ul><li><a href="/blog/ios开发高手课/02.基础篇/01"><span>01 | 建立你自己的iOS开发知识体系</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/02"><span>02 | App 启动速度怎么做优化与监控？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/03"><span>03 | Auto Layout 是怎么进行自动布局的，性能如何？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/04"><span>04 | 项目大了人员多了，架构怎么设计更合理？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/05"><span>05 | 链接器：符号是怎么绑定到地址上的？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/06"><span>06 | App 如何通过注入动态库的方式实现极速编译调试？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/07"><span>07 | Clang、Infer 和 OCLint ，我们应该使用谁来做静态分析？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/08"><span>08 | 如何利用 Clang 为 App 提质？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/09"><span>09 | 无侵入的埋点方案如何实现？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/10"><span>10 | 包大小：如何从资源和代码层面实现全方位瘦身？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/11"><span>11 | 热点问题答疑（一）：基础模块问题答疑</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/12"><span>12 | iOS 崩溃千奇百怪，如何全面监控？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/13"><span>13 | 如何利用 RunLoop 原理去监控卡顿？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/14"><span>14 | 临近 OOM，如何获取详细内存分配信息，分析内存问题？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/15"><span>15 | 日志监控：怎样获取 App 中的全量日志？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/16"><span>16 | 性能监控：衡量 App 质量的那把尺</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/17"><span>17 | 远超你想象的多线程的那些坑</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/18"><span>18 | 怎么减少 App 电量消耗？</span></a></li><li><a aria-current="page" class="active" href="/blog/ios开发高手课/02.基础篇/19"><span>19 | 热点问题答疑（二）：基础模块问题答疑</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/20"><span>20 | iOS开发的最佳学习路径是什么？</span></a></li></ul></li><li><a href="/blog/ios开发高手课/03.应用开发篇">03.应用开发篇</a><ul><li><a href="/blog/ios开发高手课/03.应用开发篇/01"><span>21 | 除了 Cocoa，iOS还可以用哪些 GUI 框架开发？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/02"><span>22 | 细说 iOS 响应式框架变迁，哪些思想可以为我所用？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/03"><span>23 | 如何构造酷炫的物理效果和过场动画效果？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/04"><span>24 | A/B 测试：验证决策效果的利器</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/05"><span>25 | 怎样构建底层的发布和订阅事件总线？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/06"><span>26 | 如何提高 JSON 解析的性能？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/07"><span>27 | 如何用 Flexbox 思路开发？跟自动布局比，Flexbox 好在哪？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/08"><span>28 | 怎么应对各种富文本表现需求？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/09"><span>29 | 如何在 iOS 中进行面向测试驱动开发和面向行为驱动开发？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/10"><span>30 | 如何制定一套适合自己团队的 iOS 编码规范？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/11"><span>31 | iOS 开发学习资料和书单推荐</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/12"><span>32 | 热点问题答疑（三）</span></a></li></ul></li><li><a href="/blog/ios开发高手课/04.原理篇">04.原理篇</a><ul><li><a href="/blog/ios开发高手课/04.原理篇/01"><span>33 | iOS 系统内核 XNU：App 如何加载？</span></a></li><li><a href="/blog/ios开发高手课/04.原理篇/02"><span>34 | iOS 黑魔法 Runtime Method Swizzling 背后的原理</span></a></li><li><a href="/blog/ios开发高手课/04.原理篇/03"><span>35 | libffi：动态调用和定义 C 函数</span></a></li><li><a href="/blog/ios开发高手课/04.原理篇/04"><span>36 | iOS 是怎么管理内存的？</span></a></li><li><a href="/blog/ios开发高手课/04.原理篇/05"><span>37 | 如何编写 Clang 插件？</span></a></li><li><a href="/blog/ios开发高手课/04.原理篇/06"><span>38 | 热点问题答疑（四）</span></a></li></ul></li><li><a href="/blog/ios开发高手课/05.原生与前端共舞">05.原生与前端共舞</a><ul><li><a href="/blog/ios开发高手课/05.原生与前端共舞/01"><span>39 | 打通前端与原生的桥梁：JavaScriptCore 能干哪些事情？</span></a></li><li><a href="/blog/ios开发高手课/05.原生与前端共舞/02"><span>40 | React Native、Flutter 等，这些跨端方案怎么选？</span></a></li><li><a href="/blog/ios开发高手课/05.原生与前端共舞/03"><span>41 | 原生布局转到前端布局，开发思路有哪些转变？</span></a></li><li><a href="/blog/ios开发高手课/05.原生与前端共舞/04"><span>42 | iOS原生、大前端和Flutter分别是怎么渲染的？</span></a></li><li><a href="/blog/ios开发高手课/05.原生与前端共舞/05"><span>43 | 剖析使 App 具有动态化和热更新能力的方案</span></a></li></ul></li><li><a href="/blog/ios开发高手课/06.用户故事">06.用户故事</a><ul><li><a href="/blog/ios开发高手课/06.用户故事/01"><span>用户故事 | 我是如何学习这个专栏的？</span></a></li></ul></li><li><a href="/blog/ios开发高手课/07.结束语">07.结束语</a><ul><li><a href="/blog/ios开发高手课/07.结束语/01"><span>结束语 | 慢几步，深几度</span></a></li><li><a href="/blog/ios开发高手课/07.结束语/02"><span>结课测试 | 这些iOS的开发知识你都掌握了吗？</span></a></li></ul></li><li><a href="/blog/ios开发高手课/summary">ios开发高手课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="使用 dlopen() 能不能审核通过？" data-depth="2"><a href="/blog/ios开发高手课/02.基础篇/19#使用-dlopen-能不能审核通过"><span>使用 dlopen() 能不能审核通过？</span></a></li><li title="matrix-iOS" data-depth="2"><a href="/blog/ios开发高手课/02.基础篇/19#matrix-ios"><span>matrix-iOS</span></a></li><li title="子线程监控检测时间间隔" data-depth="3"><a href="/blog/ios开发高手课/02.基础篇/19#子线程监控检测时间间隔"><span>子线程监控检测时间间隔</span></a></li><li title="子线程监控退火算法" data-depth="3"><a href="/blog/ios开发高手课/02.基础篇/19#子线程监控退火算法"><span>子线程监控退火算法</span></a></li><li title="RunLoop 卡顿时间阈值设置" data-depth="3"><a href="/blog/ios开发高手课/02.基础篇/19#runloop-卡顿时间阈值设置"><span>RunLoop 卡顿时间阈值设置</span></a></li><li title="CPU 使用率阈值设置" data-depth="3"><a href="/blog/ios开发高手课/02.基础篇/19#cpu-使用率阈值设置"><span>CPU 使用率阈值设置</span></a></li><li title="总结" data-depth="2"><a href="/blog/ios开发高手课/02.基础篇/19#总结"><span>总结</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="19--热点问题答疑二基础模块问题答疑"><a aria-hidden="true" tabindex="-1" href="/blog/ios开发高手课/02.基础篇/19#19--热点问题答疑二基础模块问题答疑"><span class="icon icon-link"></span></a>19 | 热点问题答疑（二）：基础模块问题答疑</h1><p>你好，我是戴铭。</p><p>这是我们《iOS开发高手课》专栏的第二期答疑文章，我将继续和你分享大家在学习前面文章时遇到的最普遍的问题。</p><p>首先呢，我要感谢你这段时间对专栏的关注，让我感觉写专栏这件事儿格外有意义。通过这段时间对大家留言问题的观察，我也发现还有很多同学对 RunLoop 原理的一些基础概念不是很了解。这就导致在出现了比如卡顿或者线程问题时找不到好的解决方案，所以我今天就先和你分享一下学习RunLoop的方法和参考资料。</p><p>其实，<strong>目前关于RunLoop 原理的高质量资料非常多，那我们究竟应该怎么利用这些资料，来高效地掌握RunLoop的原理呢？</strong></p><p>我建议你按照下面的顺序来学习RunLoop 原理，坚持下来你就会对RunLoop的基础概念掌握得八九不离十了。</p><ul><li>首先，你可以看一下孙源的一个线下分享《<a target="_blank" rel="noopener noreferrer" href="https://v.youku.com/v_show/id_XODgxODkzODI0.html">RunLoop<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》，对 RunLoop 的整体有个了解。</li><li>然后，你可以再看<a target="_blank" rel="noopener noreferrer" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，全面详细地了解苹果公司设计的 RunLoop 机制，以及如何运用 RunLoop来解决问题。</li><li>最后，了解了RunLoop的机制和运用后，你需要深入了解 RunLoop 的实现，掌握 RunLoop 原理中的基础概念。ibireme 的一篇文章 《<a target="_blank" rel="noopener noreferrer" href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》，结合着底层 CFRunLoop 的源码，对RunLoop 机制进行了深入分析。</li></ul><p>好了，关于RunLoop原理学习的内容，我就先说到这里。接下来，<strong>我再跟你说说最近被问到的，我认为比较重要的两个问题：</strong></p><ul><li>一个是，使用 dlopen() ，App能不能审核通过？</li><li>另一个是， matrix-iOS 里的卡顿监控系统，与我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/89494">第13篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里提到的卡顿监控系统有什么区别？</li></ul><p>其实，我知道大家还都比较关注课后作业的解题思路，但是考虑到有很多同学还没有静下心来去思考、去完成，所以我准备过一段时间再和你分享这部分内容。这里，我还是想再和你分享一下我在开篇词中提出的观点：</p><blockquote><p>对于咱们手艺人来说，不动手都是空谈，就像绘画教程，光看不练，是不会有进步的。这就如同九阴真经的口诀，铭记于心后还需要常年累月的修炼才能精进。动手就会碰到问题，就会思考，这个主动过程会加深你的记忆，这样后面再碰到问题时，你会更容易将相关知识串联起来，形成创新式的思考。</p></blockquote><p>这些作业确实有难度，也确实需要你投入很多精力，如果你在动手解决这些问题的过程中，具体有哪里卡住了，欢迎给我留言。我可以针对你遇到的问题给出有针对性的解答，或许这样对你的帮助会更大。</p><p>现在，我们就从第一个问题说起吧。</p><h2 id="使用-dlopen-能不能审核通过"><a aria-hidden="true" tabindex="-1" href="/blog/ios开发高手课/02.基础篇/19#使用-dlopen-能不能审核通过"><span class="icon icon-link"></span></a>使用 dlopen() 能不能审核通过？</h2><p>@Ant同学在第6篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/87188">App 如何通过注入动态库的方式实现极速编译调试？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”中留言问到：</p><blockquote><p>Injection 使用了 dlopen() 方法，审核能通过吗？ 是不是调试的时候用，提交App Store时候移除呢？</p></blockquote><p>苹果公司关于App审核的规定，你可以点击<a target="_blank" rel="noopener noreferrer" href="https://developer.apple.com/cn/app-store/review/guidelines/">这个链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>查看。其中2.5.2规定如下：</p><blockquote><p>App 应自包含在自己的套装中，不得在指定容器范围外读取或写入数据，也不得下载、安装或执行会引入或更改 App 特性或功能的代码，包括其他 App。仅在特殊情况下，用于教授、开发或允许学生测试可执行代码的教育类 App 可以下载所提供的代码，但这类代码不得用于其他用途。这类 App 必须开放 App 提供的源代码，让客户可以完全查看和编辑这些源代码。</p></blockquote><p>2018年11月，苹果公司集中下线了718个 App，主要原因就是它们违反了 2.5.2 这个条款，下面是苹果公司对于违反了 2.5.2条款的回复：</p><blockquote><p>Your app, extension, and/or linked framework appears to contain code designed explicitly with the capability to change your app’s behavior or functionality after App Review approval, which is not in compliance with App Store Review Guideline 2.5.2 and section 3.3.2 of the Apple Developer Program License Agreement.</p></blockquote><blockquote><p>This code, combined with a remote resource, can facilitate significant changes to your app’s behavior compared to when it was initially reviewed for the App Store. While you may not be using this functionality currently, it has the potential to load private frameworks, private methods, and enable future feature changes. This includes any code which passes arbitrary parameters to dynamic methods such as dlopen(), dlsym(), respondsToSelector:, performSelector:, method_exchangeImplementations(), and running remote scripts in order to change app behavior and/or call SPI, based on the contents of the downloaded script. Even if the remote resource is not intentionally malicious, it could easily be hijacked via a Man In The Middle (MiTM) attack, which can pose a serious security vulnerability to users of your app.</p></blockquote><p>苹果公司在这段回复中，提到了使用 dlopen()、dlsym()、respondsToSelector:、performSelector:、 method_exchangeImplementations() 这些方法去执行远程脚本，是不被允许的。因为这些方法和远程资源相结合，可能加载私有框架和私有方法，可能使 App 的行为发生重大变化。这就会和审核时的情况不一样，即使使用的远程资源本身不是恶意的，但是它们也很容易被劫持，给用户带来不可预计的伤害，使得应用程序有安全漏洞。</p><p>其实，我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/88799">第11篇答疑文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里就提到，<strong>苹果公司不允许通过运行时加载远程动态库的 App 上线 App Store。</strong></p><p>那么现在，我们回到 Ant同学提的问题本身，App 带着 Injection 上线后，如果使用 dlopen() 去读取远程动态库，就会被拒绝。另外，在我看来，Injection 本来就是用于线下调试的，为什么还要带着它上 App Store 呢。</p><p>下面我来说下第二个问题，matrix-iOS 里卡顿监控系统，与我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/89494">第13篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里提到的卡顿监控系统有什么区别？</p><h2 id="matrix-ios"><a aria-hidden="true" tabindex="-1" href="/blog/ios开发高手课/02.基础篇/19#matrix-ios"><span class="icon icon-link"></span></a>matrix-iOS</h2><p><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/89494">第13篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上线后，有很多朋友和我反馈说，微信最近开源了一个卡顿监控系统 <a target="_blank" rel="noopener noreferrer" href="https://github.com/tencent/matrix/tree/master/matrix/matrix-iOS">matrix-iOS<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，并询问我它和我在这篇文章里提到的卡顿监控系统，有什么区别。</p><p>因为matrix-iOS 对性能的优化考虑得非常全面，这些优化不仅能够应用在卡顿监控上，对于其他监控都有很好的借鉴作用，所以非常值得我们深入了解一下。接下来，我就这个话题和你展开一下。</p><p>记得在2015年8月的时候，微信团队的一位同学做了一次关于iOS卡顿监控方案的分享。这次分享让我受益匪浅，而且这也是我第一次听说 iOS 卡顿监控方案。次月，微信团队就放出了一篇文章专门介绍卡顿监控方案“<a target="_blank" rel="noopener noreferrer" href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207890859&amp;idx=1&amp;sn=e98dd604cdb854e7a5808d2072c29162&amp;scene=4">微信iOS卡顿监控系统<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。之后，很多团队参照这篇文章开发了自己的卡顿监控系统。我在第13篇文章中设计的卡顿监控系统，也是按照这个思路写的。</p><p>在今年的4月3号，微信团队将他们的卡顿监控系统<a target="_blank" rel="noopener noreferrer" href="https://github.com/Tencent/matrix">matrix<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>开源出来了，包括<a target="_blank" rel="noopener noreferrer" href="https://github.com/Tencent/matrix/tree/master/matrix/matrix-iOS">Matrix for iOS/macOS<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和<a target="_blank" rel="noopener noreferrer" href="https://github.com/Tencent/matrix/tree/master/matrix/matrix-android">Android<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>系统的监控方案。关于matrix-iOS的卡顿监控原理，你可以点击<a target="_blank" rel="noopener noreferrer" href="https://github.com/Tencent/matrix/wiki/Matrix-for-iOS-macOS-%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%8E%A7%E5%8E%9F%E7%90%86">这个链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>查看。</p><p>如果你的 App 现在还没有卡顿监控系统，可以考虑直接集成 matrix-iOS，直接在 Podfile 里添加 pod ‘matrix-wechat’ 就可以了。如果已经有了卡顿监控系统，我建议你阅读下 matrix-iOS 的代码，里面有很多细节值得我们学习。比如：</p><ul><li>子线程监控检测时间间隔：matrix-iOS 监控卡顿的子线程是通过 NSThread 创建的，检测时间间隔正常情况是1秒，在出现卡顿情况下，间隔时间会受检测线程退火算法影响，按照<a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Fibonacci_number">斐波那契数列<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>递增，直到没有卡顿时恢复为1秒。</li><li>子线程监控退火算法：避免一个卡顿会写入多个文件的情况。</li><li>RunLoop 卡顿时间阈值设置：对于 RunLoop 超时阈值的设置，我在第13篇文章里建议设置为3秒，微信设置的是2秒。</li><li>CPU 使用率阈值设置：当单核 CPU 使用率超过 80%，就判定 CPU 占用过高。CPU 使用率过高，可能导致 App 卡顿。</li></ul><p>在我看来，这四点是能够让卡顿监控系统在对 App 性能损耗很小的情况下，更好地监控到线上 App 卡顿情况的四个细节，也是和我们<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/89494">第13篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中的卡顿方案有所不同的地方。</p><p>那接下来，我就跟你说下 matrix-iOS 的这四处细节具体是如何实现的吧。matrix-iOS 卡顿监控系统的主要代码在 <a target="_blank" rel="noopener noreferrer" href="https://github.com/Tencent/matrix/blob/master/matrix/matrix-iOS/Matrix/WCCrashBlockMonitor/CrashBlockPlugin/Main/BlockMonitor/WCBlockMonitorMgr.mm">WCBlockMonitorMgr.mm<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>文件中。</p><h3 id="子线程监控检测时间间隔"><a aria-hidden="true" tabindex="-1" href="/blog/ios开发高手课/02.基础篇/19#子线程监控检测时间间隔"><span class="icon icon-link"></span></a>子线程监控检测时间间隔</h3><p>matrix-iOS 是在 addMonitorThread 方法里，通过 NSThread 添加一个子线程来进行监控的。addMonitorThread 方法代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">- (void)addMonitorThread</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        m_bStop = NO;</span></div><div class="token-line"><span class="token plain">        m_monitorThread = [[NSThread alloc] initWithTarget:self selector:@selector(threadProc) object:nil];</span></div><div class="token-line"><span class="token plain">        [m_monitorThread start];</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码中创建的 NSThread 子线程，会去执行 threadProc 方法。这个方法包括了子线程监控卡顿的所有逻辑。它的代码比较多，我先和你分析与检测时间间隔相关的代码，然后再和你分析其他的主要代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">while (YES) {</span></div><div class="token-line"><span class="token plain">        @autoreleasepool {</span></div><div class="token-line"><span class="token plain">            if (g_bMonitor) {</span></div><div class="token-line"><span class="token plain">                // 检查是否卡顿，以及卡顿原因</span></div><div class="token-line"><span class="token plain">                ...</span></div><div class="token-line"><span class="token plain">                // 针对不同卡顿原因进行不同的处理</span></div><div class="token-line"><span class="token plain">                ...</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            // 时间间隔处理，检测时间间隔正常情况是1秒，间隔时间会受检测线程退火算法影响，按照斐波那契数列递增，直到没有卡顿时恢复为1秒。</span></div><div class="token-line"><span class="token plain">            for (int nCnt = 0; nCnt &lt; m_nIntervalTime &amp;&amp; !m_bStop; nCnt++) {</span></div><div class="token-line"><span class="token plain">                if (g_MainThreadHandle &amp;&amp; g_bMonitor) {</span></div><div class="token-line"><span class="token plain">                    int intervalCount = g_CheckPeriodTime / g_PerStackInterval;</span></div><div class="token-line"><span class="token plain">                    if (intervalCount &lt;= 0) {</span></div><div class="token-line"><span class="token plain">                        usleep(g_CheckPeriodTime);</span></div><div class="token-line"><span class="token plain">                    } else {</span></div><div class="token-line"><span class="token plain">                        ...</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                } else {</span></div><div class="token-line"><span class="token plain">                    usleep(g_CheckPeriodTime);</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            if (m_bStop) {</span></div><div class="token-line"><span class="token plain">                break;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div></pre></div><p>可以看出，创建的子线程通过 while 使其成为常驻线程，直到主动执行 stop 方法才会被销毁。其中，使用 usleep 方法进行时间间隔操作， g_CheckPeriodTime就是正常情况的时间间隔的值，退火算法影响的是 m_nIntervalTime，递增后检测卡顿的时间间隔就会不断变长。直到判定卡顿已结束，m_nIntervalTime 的值会恢复成1。</p><p>接下来，跟踪 g_CheckPeriodTime 的定义就能够找到正常情况下子线程卡顿监控的时间间隔。 g_CheckPeriodTime 的定义如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static useconds_t g_CheckPeriodTime = g_defaultCheckPeriodTime;</span></div></pre></div><p>其中 g_defaultCheckPeriodTime 的定义是：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define BM_MicroFormat_Second 1000000</span></div><div class="token-line"><span class="token plain">    const static useconds_t g_defaultCheckPeriodTime = 1 * BM_MicroFormat_Second;</span></div></pre></div><p>可以看出，子线程监控检测时间间隔g_CheckPeriodTime，被设置的值就是1秒。</p><h3 id="子线程监控退火算法"><a aria-hidden="true" tabindex="-1" href="/blog/ios开发高手课/02.基础篇/19#子线程监控退火算法"><span class="icon icon-link"></span></a>子线程监控退火算法</h3><p>子线程监控检测时间间隔设置为1秒，在没有卡顿问题，不需要获取主线程堆栈信息的情况下性能消耗几乎可以忽略不计。但是，当遇到卡顿问题时，而且一个卡顿持续好几秒的话，就会持续获取主线程堆栈信息，增加性能损耗。更重要的是，持续获取的这些堆栈信息都是重复的，完全没有必要。</p><p>所以，matrix-iOS 采用了退火算法递增时间间隔，来避免因为同一个卡顿问题，不断去获取主线程堆栈信息的情况，从而提升了算法性能。</p><p>同时，一个卡顿问题只获取一个主线程堆栈信息，也就是一个卡顿问题 matrix-iOS 只会进行一次磁盘存储，减少了存储 I/O 也就减少了性能消耗。</p><p>所以，这种策略能够有效减少由于获取主线程堆栈信息带来的性能消耗。</p><p>那么，<strong>matrix-iOS 是如何实现退火算法的呢？</strong></p><p>因为触发退火算法的条件是卡顿，所以我们先回头来看看子线程监控卡顿主方法 threadProc 里和发现卡顿后处理相关的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">while (YES) {</span></div><div class="token-line"><span class="token plain">        @autoreleasepool {</span></div><div class="token-line"><span class="token plain">            if (g_bMonitor) {</span></div><div class="token-line"><span class="token plain">                // 检查是否卡顿，以及卡顿原因</span></div><div class="token-line"><span class="token plain">                EDumpType dumpType = [self check];</span></div><div class="token-line"><span class="token plain">                if (m_bStop) {</span></div><div class="token-line"><span class="token plain">                    break;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                // 针对不同卡顿原因进行不同的处理</span></div><div class="token-line"><span class="token plain">                ...</span></div><div class="token-line"><span class="token plain">                if (dumpType != EDumpType_Unlag) {</span></div><div class="token-line"><span class="token plain">                    if (EDumpType_BackgroundMainThreadBlock == dumpType ||</span></div><div class="token-line"><span class="token plain">                        EDumpType_MainThreadBlock == dumpType) {</span></div><div class="token-line"><span class="token plain">                        if (g_CurrentThreadCount &gt; 64) {</span></div><div class="token-line"><span class="token plain">                            // 线程数超过64个，认为线程过多造成卡顿，不用记录主线程堆栈</span></div><div class="token-line"><span class="token plain">                            dumpType = EDumpType_BlockThreadTooMuch;</span></div><div class="token-line"><span class="token plain">                            [self dumpFileWithType:dumpType];</span></div><div class="token-line"><span class="token plain">                        } else {</span></div><div class="token-line"><span class="token plain">                            EFilterType filterType = [self needFilter];</span></div><div class="token-line"><span class="token plain">                            if (filterType == EFilterType_None) {</span></div><div class="token-line"><span class="token plain">                                if (g_MainThreadHandle) {</span></div><div class="token-line"><span class="token plain">                                    if (g_PointMainThreadArray != NULL) {</span></div><div class="token-line"><span class="token plain">                                        free(g_PointMainThreadArray);</span></div><div class="token-line"><span class="token plain">                                        g_PointMainThreadArray = NULL;</span></div><div class="token-line"><span class="token plain">                                    }</span></div><div class="token-line"><span class="token plain">                                    g_PointMainThreadArray = [m_pointMainThreadHandler getPointStackCursor];</span></div><div class="token-line"><span class="token plain">                                    // 函数主线程堆栈写文件记录</span></div><div class="token-line"><span class="token plain">                                    m_potenHandledLagFile = [self dumpFileWithType:dumpType];</span></div><div class="token-line"><span class="token plain">                                    // 回调处理主线程堆栈文件</span></div><div class="token-line"><span class="token plain">                                    ...</span></div><div class="token-line"><span class="token plain">                                    </span></div><div class="token-line"><span class="token plain">                                } else {</span></div><div class="token-line"><span class="token plain">                                    // 主线程堆栈写文件记录</span></div><div class="token-line"><span class="token plain">                                    m_potenHandledLagFile = [self dumpFileWithType:dumpType];</span></div><div class="token-line"><span class="token plain">                                    ...</span></div><div class="token-line"><span class="token plain">                                }</span></div><div class="token-line"><span class="token plain">                            } else {</span></div><div class="token-line"><span class="token plain">                                // 对于 filterType 满足退火算法、主线程堆栈数太少、一天内记录主线程堆栈过多这些情况不用进行写文件操作</span></div><div class="token-line"><span class="token plain">                                ...</span></div><div class="token-line"><span class="token plain">                            }</span></div><div class="token-line"><span class="token plain">                        }</span></div><div class="token-line"><span class="token plain">                    } else {</span></div><div class="token-line"><span class="token plain">                        m_potenHandledLagFile = [self dumpFileWithType:dumpType];</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                } else {</span></div><div class="token-line"><span class="token plain">                    [self resetStatus];</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 时间间隔处理，检测时间间隔正常情况是1秒，间隔时间会受检测线程退火算法影响，按照斐波那契数列递增，直到没有卡顿时恢复为1秒。</span></div><div class="token-line"><span class="token plain">            ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看出，当检测出主线程卡顿后，matrix-iOS 会先看线程数是否过多。为什么会先检查线程数呢？</p><p>我在17篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/90870">远超你想象的多线程的那些坑<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”里提到线程过多时 CPU 在切换线程上下文时，还会更新寄存器，更新寄存器时需要寻址，而寻址的过程还会有较大的 CPU 消耗。你可以借此机会再回顾下这篇文章的相关内容。</p><p>按照微信团队的经验，线程数超出64个时会导致主线程卡顿，如果卡顿是由于线程多造成的，那么就没必要通过获取主线程堆栈去找卡顿原因了。根据 matrix-iOS 的实测，每隔 50 毫秒获取主线程堆栈会增加 3% 的 CPU 占用，所以当检测到主线程卡顿以后，我们需要先判断是否是因为线程数过多导致的，而不是一有卡顿问题就去获取主线程堆栈。</p><p>如果不是线程过多造成的卡顿问题，matrix-iOS 会通过 needFilter 方法去对比前后两次获取的主线程堆栈，如果两次堆栈是一样的，那就表示卡顿还没结束，满足退火算法条件，needFilter 方法会返回 EFilterType。EFilterType 为 EFilterType_Annealing，表示类型为退火算法。满足退火算法后，主线程堆栈就不会立刻进行写文件操作。</p><p>在 needFilter 方法里，needFilter 通过 [m_pointMainThreadHandler getLastMainThreadStack] 获取当前主线程堆栈，然后记录在 m_vecLastMainThreadCallStack 里。下次卡顿时，再获取主线程堆栈，新获取的堆栈和上次记录的 m_vecLastMainThreadCallStack 堆栈进行对比：</p><ul><li>如果两个堆栈不同，表示这是一个新的卡顿，就会退出退火算法；</li><li>如果两个堆栈相同，就用斐波那契数列递增子线程检查时间间隔。</li></ul><p>递增时间的代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if (bIsSame) {</span></div><div class="token-line"><span class="token plain">        NSUInteger lastTimeInterval = m_nIntervalTime;</span></div><div class="token-line"><span class="token plain">        // 递增 m_nIntervalTime</span></div><div class="token-line"><span class="token plain">        m_nIntervalTime = m_nLastTimeInterval + m_nIntervalTime;</span></div><div class="token-line"><span class="token plain">        m_nLastTimeInterval = lastTimeInterval;</span></div><div class="token-line"><span class="token plain">        MatrixInfo(@&quot;call stack same timeinterval = %lu&quot;, (unsigned long) m_nIntervalTime);</span></div><div class="token-line"><span class="token plain">        return EFilterType_Annealing;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看出，将子线程检查主线程时间间隔增加后，needFilter 就直接返回 EFilterType_Annealing 类型表示当前情况满足退火算法。使用退火算法，可以有效降低没有必要地获取主线程堆栈的频率。这样的话，我们就能够在准确获取卡顿的前提下，还能保障 App 性能不会受卡顿监控系统的影响。</p><h3 id="runloop-卡顿时间阈值设置"><a aria-hidden="true" tabindex="-1" href="/blog/ios开发高手课/02.基础篇/19#runloop-卡顿时间阈值设置"><span class="icon icon-link"></span></a>RunLoop 卡顿时间阈值设置</h3><p>RunLoop 超时检查的相关逻辑代码都在 check 方法里。check 方法和 RunLoop 超时相关代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">- (EDumpType)check</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        // 1. RunLoop 超时判断</span></div><div class="token-line"><span class="token plain">        // RunLoop 是不是处在执行方法状态中</span></div><div class="token-line"><span class="token plain">        BOOL tmp_g_bRun = g_bRun;</span></div><div class="token-line"><span class="token plain">        // 执行了多长时间</span></div><div class="token-line"><span class="token plain">        struct timeval tmp_g_tvRun = g_tvRun;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        struct timeval tvCur;</span></div><div class="token-line"><span class="token plain">        gettimeofday(&amp;tvCur, NULL);</span></div><div class="token-line"><span class="token plain">        unsigned long long diff = [WCBlockMonitorMgr diffTime:&amp;tmp_g_tvRun endTime:&amp;tvCur];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">        m_blockDiffTime = 0;</span></div><div class="token-line"><span class="token plain">        // 判断执行时长是否超时</span></div><div class="token-line"><span class="token plain">        if (tmp_g_bRun &amp;&amp; tmp_g_tvRun.tv_sec &amp;&amp; tmp_g_tvRun.tv_usec &amp;&amp; __timercmp(&amp;tmp_g_tvRun, &amp;tvCur, &lt;) &amp;&amp; diff &gt; g_RunLoopTimeOut) {</span></div><div class="token-line"><span class="token plain">            m_blockDiffTime = tvCur.tv_sec - tmp_g_tvRun.tv_sec;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            return EDumpType_MainThreadBlock;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        // 2. CPU 使用率</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 3. 没问题</span></div><div class="token-line"><span class="token plain">        return EDumpType</span></div></pre></div><p>可以看出，在判断执行时长是否超时代码中的 g_RunLoopTimeOut 就是超时的阈值。通过这个阈值，我们就可以知道 matrix-iOS 设置的 RunLoop 卡顿时间阈值是多少了。g_RunLoopTimeOut 的定义如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static useconds_t g_RunLoopTimeOut = g_defaultRunLoopTimeOut;</span></div><div class="token-line"><span class="token plain">    const static useconds_t g_defaultRunLoopTimeOut = 2 * BM_MicroFormat_Second;</span></div></pre></div><p>可以看出，matrix-iOS 设置的 RunLoop 卡顿时间阈值是2秒。我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/89494">第13篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里设置的卡顿时间阈值是3秒，@80后空巢老肥狗在评论区留言到：</p><blockquote><p>这个3秒是不是太长了，1秒60帧，每帧16.67ms。RunLoop 会在每次sleep之前去刷新UI，这样的话如果掉了30帧，就是500ms左右，用户的体验就已经下去了，能感觉到卡顿了。</p></blockquote><p>关于卡顿时间阈值设置的这个问题，其实我和 matrix-iOS 的想法是一致的。你在实际使用时，如果把这个阈值设置为2秒后发现的线上卡顿问题比较多，短期内无法全部修复的话，可以选择把这个值设置为3秒。</p><p>还有一点我需要再说明一下，**我们所说的卡顿监控方案，主要是针对那些在一段时间内用户无法点击，通过日志也很难复现问题的情况而做的。这样的卡顿问题属于头部问题，对用户的伤害是最大的，是需要优先解决的。**这种方案，是不适合短时间掉帧的情况的。短时间掉帧问题对用户体验也有影响，但是属于优化问题。</p><p>除了 RunLoop 超时会造成卡顿问题外，在 check 方法里还有对于 CPU 使用率的判断处理，那么我再带你来看看 matrix-iOS 是如何通过 CPU 使用率来判断卡顿的。</p><h3 id="cpu-使用率阈值设置"><a aria-hidden="true" tabindex="-1" href="/blog/ios开发高手课/02.基础篇/19#cpu-使用率阈值设置"><span class="icon icon-link"></span></a>CPU 使用率阈值设置</h3><p>我在第18篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/90874">怎么减少 App 电量消耗？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”中，设置的 CPU 使用率阈值是 90%。那么，matrix-iOS 是如何设置这个 CPU 使用率阈值的呢？check 方法里的相关代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if (m_bTrackCPU) {</span></div><div class="token-line"><span class="token plain">        unsigned long long checkPeriod = [WCBlockMonitorMgr diffTime:&amp;g_lastCheckTime endTime:&amp;tvCur];</span></div><div class="token-line"><span class="token plain">        gettimeofday(&amp;g_lastCheckTime, NULL);</span></div><div class="token-line"><span class="token plain">        // 检查是否超过 CPU 使用率阈值限制，报 CPU 使用率一段时间过高</span></div><div class="token-line"><span class="token plain">        if ([m_cpuHandler cultivateCpuUsage:cpuUsage periodTime:(float)checkPeriod / 1000000]) {</span></div><div class="token-line"><span class="token plain">            MatrixInfo(@&quot;exceed cpu average usage&quot;);</span></div><div class="token-line"><span class="token plain">            BM_SAFE_CALL_SELECTOR_NO_RETURN(_delegate, @selector(onBlockMonitorIntervalCPUTooHigh:), onBlockMonitorIntervalCPUTooHigh:self)</span></div><div class="token-line"><span class="token plain">            if ([_monitorConfigHandler getShouldGetCPUIntervalHighLog]) {</span></div><div class="token-line"><span class="token plain">                return EDumpType_CPUIntervalHigh;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        // 针对 CPU 满负荷情况，直接报 CPU 使用率过高引起卡顿</span></div><div class="token-line"><span class="token plain">        if (cpuUsage &gt; g_CPUUsagePercent) {</span></div><div class="token-line"><span class="token plain">            MatrixInfo(@&quot;check cpu over usage dump %f&quot;, cpuUsage);</span></div><div class="token-line"><span class="token plain">            BM_SAFE_CALL_SELECTOR_NO_RETURN(_delegate, @selector(onBlockMonitorCurrentCPUTooHigh:), onBlockMonitorCurrentCPUTooHigh:self)</span></div><div class="token-line"><span class="token plain">            if ([_monitorConfigHandler getShouldGetCPUHighLog]) {</span></div><div class="token-line"><span class="token plain">                return EDumpType_CPUBlock;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>通过上面代码，你会发现 matrix-iOS 使用了两个阈值，分别返回两种类型的问题，对应两种导致卡顿的情况：</p><ul><li>一个是， CPU 已经满负荷，直接返回 CPU 使用率过高引起卡顿；</li><li>另一个是，持续时间内 CPU 使用率一直超过某个阈值，就返回 CPU 使用率造成了卡顿。</li></ul><p>如上面代码所示，CPU 使用率阈值就在 cultivateCpuUsage:cpuUsage periodTime:periodSec 方法里。阈值相关逻辑代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if (cpuUsage &gt; 80. &amp;&amp; m_tickTok == 0 &amp;&amp; m_bLastOverEighty == NO) {</span></div><div class="token-line"><span class="token plain">        MatrixInfo(@&quot;start track cpu usage&quot;);</span></div><div class="token-line"><span class="token plain">        m_foregroundOverEightyTotalSec = 0;</span></div><div class="token-line"><span class="token plain">        m_backgroundOverEightyTotalSec = 0;</span></div><div class="token-line"><span class="token plain">        m_bLastOverEighty = YES;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，matrix-iOS 设置的 CPU 使用率阈值是80%。</p><p>到这里，我就已经把 matrix-iOS 的卡顿监控系统4个非常值得我们学习的细节说完了。而matrix-iOS 如何利用 RunLoop 原理去获取卡顿时长的原理，我已经在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/89494">第13篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里跟你说过，这里就不再赘述了。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/ios开发高手课/02.基础篇/19#总结"><span class="icon icon-link"></span></a>总结</h2><p>在今天这篇文章中，我和你分享了下最近这段时间大家对专栏文章的一些问题。</p><p>首先，是关于对RunLoop原理的学习。我发现有很多同学在这方面的基础比较薄弱，所以特意梳理了这方面的学习方法和资料，希望可以帮到你。</p><p>然后，我针对大家比较关注的苹果公司审核动态化的相关规定，通过Injection里面带dlopen()方法能否审核通过和你做了说明，希望可以帮助你了解类似 dlopen()这样的技术应该怎样使用。</p><p>最后，我针对第13篇文章的监控系统，分析了最近微信团队新开源的matrix-iOS监控系统，为你详细分析了其中与卡顿监控相关的实现细节，也希望对你完善自己的监控系统有所帮助。</p><p>感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎把它分享给更多的朋友一起阅读。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/ios开发高手课/02.基础篇/19.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 14:44:21</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
