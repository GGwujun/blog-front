<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>15 | 日志监控：怎样获取 App 中的全量日志？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/ios开发高手课/02.基础篇/15" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础</span><span>算法<ul><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackchain">webpackchain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>移动端开发<ul><li><a href="/blog/android开发高手课">android开发高手课</a></li><li><a aria-current="page" class="active" href="/blog/ios开发高手课">ios开发高手课</a></li></ul></span><span>软件测试</span><span>产品与用户体验<ul><li><a href="/blog/视觉笔记入门课">视觉笔记入门课</a></li></ul></span><span>面试</span><span>杂谈<ul><li><a href="/blog/git实战手册">git实战手册</a></li><li><a href="/blog/nodejs">nodejs</a></li><li><a href="/blog/reactjs">reactjs</a></li><li><a href="/blog/ui设计">ui设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础</li><li>算法<ul><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackchain">webpackchain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>移动端开发<ul><li><a href="/blog/android开发高手课">android开发高手课</a></li><li><a aria-current="page" class="active" href="/blog/ios开发高手课">ios开发高手课</a></li></ul></li><li>软件测试</li><li>产品与用户体验<ul><li><a href="/blog/视觉笔记入门课">视觉笔记入门课</a></li></ul></li><li>面试</li><li>杂谈<ul><li><a href="/blog/git实战手册">git实战手册</a></li><li><a href="/blog/nodejs">nodejs</a></li><li><a href="/blog/reactjs">reactjs</a></li><li><a href="/blog/ui设计">ui设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/ios开发高手课">ios开发高手课</a></li><li><a href="/blog/ios开发高手课/01.开篇词">01.开篇词</a><ul><li><a href="/blog/ios开发高手课/01.开篇词/01"><span>开篇词 | 锚定一个点，然后在这个点上深耕</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/ios开发高手课/02.基础篇">02.基础篇</a><ul><li><a href="/blog/ios开发高手课/02.基础篇/01"><span>01 | 建立你自己的iOS开发知识体系</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/02"><span>02 | App 启动速度怎么做优化与监控？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/03"><span>03 | Auto Layout 是怎么进行自动布局的，性能如何？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/04"><span>04 | 项目大了人员多了，架构怎么设计更合理？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/05"><span>05 | 链接器：符号是怎么绑定到地址上的？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/06"><span>06 | App 如何通过注入动态库的方式实现极速编译调试？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/07"><span>07 | Clang、Infer 和 OCLint ，我们应该使用谁来做静态分析？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/08"><span>08 | 如何利用 Clang 为 App 提质？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/09"><span>09 | 无侵入的埋点方案如何实现？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/10"><span>10 | 包大小：如何从资源和代码层面实现全方位瘦身？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/11"><span>11 | 热点问题答疑（一）：基础模块问题答疑</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/12"><span>12 | iOS 崩溃千奇百怪，如何全面监控？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/13"><span>13 | 如何利用 RunLoop 原理去监控卡顿？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/14"><span>14 | 临近 OOM，如何获取详细内存分配信息，分析内存问题？</span></a></li><li><a aria-current="page" class="active" href="/blog/ios开发高手课/02.基础篇/15"><span>15 | 日志监控：怎样获取 App 中的全量日志？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/16"><span>16 | 性能监控：衡量 App 质量的那把尺</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/17"><span>17 | 远超你想象的多线程的那些坑</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/18"><span>18 | 怎么减少 App 电量消耗？</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/19"><span>19 | 热点问题答疑（二）：基础模块问题答疑</span></a></li><li><a href="/blog/ios开发高手课/02.基础篇/20"><span>20 | iOS开发的最佳学习路径是什么？</span></a></li></ul></li><li><a href="/blog/ios开发高手课/03.应用开发篇">03.应用开发篇</a><ul><li><a href="/blog/ios开发高手课/03.应用开发篇/01"><span>21 | 除了 Cocoa，iOS还可以用哪些 GUI 框架开发？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/02"><span>22 | 细说 iOS 响应式框架变迁，哪些思想可以为我所用？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/03"><span>23 | 如何构造酷炫的物理效果和过场动画效果？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/04"><span>24 | A/B 测试：验证决策效果的利器</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/05"><span>25 | 怎样构建底层的发布和订阅事件总线？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/06"><span>26 | 如何提高 JSON 解析的性能？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/07"><span>27 | 如何用 Flexbox 思路开发？跟自动布局比，Flexbox 好在哪？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/08"><span>28 | 怎么应对各种富文本表现需求？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/09"><span>29 | 如何在 iOS 中进行面向测试驱动开发和面向行为驱动开发？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/10"><span>30 | 如何制定一套适合自己团队的 iOS 编码规范？</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/11"><span>31 | iOS 开发学习资料和书单推荐</span></a></li><li><a href="/blog/ios开发高手课/03.应用开发篇/12"><span>32 | 热点问题答疑（三）</span></a></li></ul></li><li><a href="/blog/ios开发高手课/04.原理篇">04.原理篇</a><ul><li><a href="/blog/ios开发高手课/04.原理篇/01"><span>33 | iOS 系统内核 XNU：App 如何加载？</span></a></li><li><a href="/blog/ios开发高手课/04.原理篇/02"><span>34 | iOS 黑魔法 Runtime Method Swizzling 背后的原理</span></a></li><li><a href="/blog/ios开发高手课/04.原理篇/03"><span>35 | libffi：动态调用和定义 C 函数</span></a></li><li><a href="/blog/ios开发高手课/04.原理篇/04"><span>36 | iOS 是怎么管理内存的？</span></a></li><li><a href="/blog/ios开发高手课/04.原理篇/05"><span>37 | 如何编写 Clang 插件？</span></a></li><li><a href="/blog/ios开发高手课/04.原理篇/06"><span>38 | 热点问题答疑（四）</span></a></li></ul></li><li><a href="/blog/ios开发高手课/05.原生与前端共舞">05.原生与前端共舞</a><ul><li><a href="/blog/ios开发高手课/05.原生与前端共舞/01"><span>39 | 打通前端与原生的桥梁：JavaScriptCore 能干哪些事情？</span></a></li><li><a href="/blog/ios开发高手课/05.原生与前端共舞/02"><span>40 | React Native、Flutter 等，这些跨端方案怎么选？</span></a></li><li><a href="/blog/ios开发高手课/05.原生与前端共舞/03"><span>41 | 原生布局转到前端布局，开发思路有哪些转变？</span></a></li><li><a href="/blog/ios开发高手课/05.原生与前端共舞/04"><span>42 | iOS原生、大前端和Flutter分别是怎么渲染的？</span></a></li><li><a href="/blog/ios开发高手课/05.原生与前端共舞/05"><span>43 | 剖析使 App 具有动态化和热更新能力的方案</span></a></li></ul></li><li><a href="/blog/ios开发高手课/06.用户故事">06.用户故事</a><ul><li><a href="/blog/ios开发高手课/06.用户故事/01"><span>用户故事 | 我是如何学习这个专栏的？</span></a></li></ul></li><li><a href="/blog/ios开发高手课/07.结束语">07.结束语</a><ul><li><a href="/blog/ios开发高手课/07.结束语/01"><span>结束语 | 慢几步，深几度</span></a></li><li><a href="/blog/ios开发高手课/07.结束语/02"><span>结课测试 | 这些iOS的开发知识你都掌握了吗？</span></a></li></ul></li><li><a href="/blog/ios开发高手课/summary">ios开发高手课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="获取 NSLog 的日志" data-depth="2"><a href="/blog/ios开发高手课/02.基础篇/15#获取-nslog-的日志"><span>获取 NSLog 的日志</span></a></li><li title="获取 CocoaLumberjack 日志" data-depth="2"><a href="/blog/ios开发高手课/02.基础篇/15#获取-cocoalumberjack-日志"><span>获取 CocoaLumberjack 日志</span></a></li><li title="小结" data-depth="2"><a href="/blog/ios开发高手课/02.基础篇/15#小结"><span>小结</span></a></li><li title="课后作业" data-depth="2"><a href="/blog/ios开发高手课/02.基础篇/15#课后作业"><span>课后作业</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="15--日志监控怎样获取-app-中的全量日志"><a aria-hidden="true" tabindex="-1" href="/blog/ios开发高手课/02.基础篇/15#15--日志监控怎样获取-app-中的全量日志"><span class="icon icon-link"></span></a>15 | 日志监控：怎样获取 App 中的全量日志？</h1><p>你好，我是戴铭。</p><p>我在前面的第12、13和14三篇文章中，和你分享了崩溃、卡顿、内存问题的监控。一旦监控到问题，我们还需要记录下问题的详细信息，形成日志告知开发者，这样开发者才能够从这些日志中定位问题。</p><p>但是，很多问题的定位仅靠问题发生的那一刹那记录的信息是不够的，我们还需要依赖更多的日志信息。</p><p>在以前公司还没有全量日志的时候，我发现线上有一个上报到服务器的由数据解析出错而引起崩溃的问题。由于数据解析是在生成数据后在另一个线程延迟执行的，所以很难定位到是谁生成的数据造成了崩溃。</p><p>如果这个时候，我能够查看到崩溃前的所有日志，包括手动打的日志和无侵入自动埋点的日志，就能够快速定位到是由谁生成的数据造成了崩溃。这些在 App 里记录的所有日志，比如用于记录用户行为和关键操作的日志，就是全量日志了。</p><p>有了更多的信息，才更利于开发者去快速、精准地定位各种复杂问题，并提高解决问题的效率。那么，<strong>怎样才能够获取到 App 里更多的日志呢</strong>？</p><p>你可能会觉得获取到全量的日志很容易啊，只要所有数据都通过相同的打日志库，不就可以收集到所有日志了吗？但，现实情况并没有这么简单。</p><p>一个 App 很有可能是由多个团队共同开发维护的，不同团队使用的日志库由于历史原因可能都不一样，要么是自己开发的，要么就是使用了不同第三方日志库。如果我们只是为了统一获取日志，而去推动其他团队将以前的日志库代码全部替换掉，明显是不现实的。因为，我们谁也无法确定，这种替换日志库的工作，以后是不是还会再来一次。</p><p>那么，我们还有什么好办法来解决这个问题吗？在我看来，要解决这个问题，我们就需要先逐个地分析各团队使用的日志库，使用不侵入的方式去获取所有日志。</p><p>接下来，我就先和你说说怎样获取系统自带NSLog的日志。</p><h2 id="获取-nslog-的日志"><a aria-hidden="true" tabindex="-1" href="/blog/ios开发高手课/02.基础篇/15#获取-nslog-的日志"><span class="icon icon-link"></span></a>获取 NSLog 的日志</h2><p>我们都知道，NSLog其实就是一个C函数，函数声明是：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void NSLog(NSString *format, ...);</span></div></pre></div><p>它的作用是，输出信息到标准的Error控制台和系统日志（syslog）中。在内部实现上，它其实使用的是ASL（Apple System Logger，是苹果公司自己实现的一套输出日志的接口）的API，将日志消息直接存储在磁盘上。</p><p>那么，<strong>我们如何才能获取到通过ASL存放在系统日志中的日志呢？</strong></p><p>ASL 会提供接口去查找所有的日志，通过 <a target="_blank" rel="noopener noreferrer" href="https://github.com/CocoaLumberjack/CocoaLumberjack">CocoaLumberjack<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 这个第三方日志库里的 DDASLLogCapture 这个类，我们可以找到实时捕获 NSLog 的方法。DDASLLogCapture会在 start 方法里开启一个异步全局队列去捕获 ASL 存储的日志。start 方法的代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">+ (void)start {</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(void) {</span></div><div class="token-line"><span class="token plain">            [self captureAslLogs];</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看出，捕获ASL存储日志的主要处理都在 captureAslLogs 方法里。在日志被保存到 ASL 的数据库时，syslogd（系统里用于接收分发日志消息的日志守护进程） 会发出一条通知。因为发过来的这一条通知可能会有多条日志，所以还需要先做些合并的工作，将多条日志进行合并。具体的实现，你可以查看 captureAslLogs 方法的实现，关键代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">+ (void)captureAslLogs {</span></div><div class="token-line"><span class="token plain">        @autoreleasepool {</span></div><div class="token-line"><span class="token plain">            ...</span></div><div class="token-line"><span class="token plain">            notify_register_dispatch(kNotifyASLDBUpdate, &amp;notifyToken, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0),^(int token) {</span></div><div class="token-line"><span class="token plain">                @autoreleasepool {</span></div><div class="token-line"><span class="token plain">                    ...</span></div><div class="token-line"><span class="token plain">                    // 利用进程标识兼容在模拟器情况时其他进程日志无效通知</span></div><div class="token-line"><span class="token plain">                    [self configureAslQuery:query];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                    // 迭代处理所有新日志</span></div><div class="token-line"><span class="token plain">                    aslmsg msg;</span></div><div class="token-line"><span class="token plain">                    aslresponse response = asl_search(NULL, query);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                    while ((msg = asl_next(response))) {</span></div><div class="token-line"><span class="token plain">                        // 记录日志</span></div><div class="token-line"><span class="token plain">                        [self aslMessageReceived:msg];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                        lastSeenID = (unsigned long long)atoll(asl_get(msg, ASL_KEY_MSG_ID));</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                    asl_release(response);</span></div><div class="token-line"><span class="token plain">                    asl_free(query);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                    if (_cancel) {</span></div><div class="token-line"><span class="token plain">                        notify_cancel(token);</span></div><div class="token-line"><span class="token plain">                        return;</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            });</span></div></pre></div><p>在上面这段代码中，notify_register_dispatch的作用是用来注册进程间的系统通知。其中，kNotifyASLDBUpdate 宏表示的就是，日志被保存到 ASL 数据库时发出的跨进程通知，其键值是 com.apple.system.logger.message。</p><p>既然是跨进程通知，那么多个 App 之间也是可以进行通知的。不过对于 iPhone 来说，多个 App 同时保活的机会太少，所以一般都是接收系统功能发出的通知。</p><p>在iOS系统中，类似地把日志保存到 ASL 数据库时发出的通知还有很多种，比如键值是 com.apple.system.lowdiskspace 的 kNotifyVFSLowDiskSpace 宏，该通知是在系统磁盘空间不足时发出的。当捕获到这个通知时，你可以去清理缓存空间，避免发生缓存写入磁盘失败的情况。</p><p>更多的跨进程通知宏，你可以在 notify_keys.h 里看到，终端查看命令如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">cat /usr/include/notify_keys.h</span></div></pre></div><p>接下来，<strong>我继续和你说说 captureAslLogs方法，看看 captureAslLogs 是怎么处理 ASL 日志的。</strong></p><p>在captureAslLogs方法里，处理日志的方法是 aslMessageReceived，入参是 aslmsg 类型，由于 aslmsg 类型不是字符串类型，无法直接查看。所以在 aslMessageReceived方法的开始阶段，会使用 asl_get 方法将其转换为 char 字符串类型。类型转换代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const char* messageCString = asl_get( msg, ASL_KEY_MSG );</span></div></pre></div><p>接下来，char 字符串会被转换成 NSString类型，NSString 是 Objective-C 里字符串类型，转成 NSString 更容易在 Objective-C 里使用。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">NSString *message = @(messageCString);</span></div></pre></div><p>因为CocoaLumberjack 的日志最后都是通过 DDLog:log:message: 方法进行记录的，其中 message 参数的类型是 DDLogMessage，所以 NSString类型还需要转换成 DDLogMessage 类型。</p><p>因为 DDLogMessage 类型包含了日志级别，所以转换类型后还需要设置日志的级别。CocoaLumberjack 这个第三方日志库，将捕获到的 NSLog 日志的级别设置为了 Verbose。那为什么要这么设置呢？</p><p>CocoaLumberjack 的日志级别，包括两类：</p><ul><li>第一类是Verbose 和 Debug ，属于调试级；</li><li>第二类是Info、Warn、Error ，属于正式级，适用于记录更重要的信息，是需要持久化存储的。特别是，Error可以理解为严重级别最高。</li></ul><p>将日志级别定义为 Verbose，也只是基于CocoaLumberjack 对 NSLog日志的理解。其实，NSLog是被苹果公司专门定义为记录错误信息的：</p><blockquote><p>Logs an error message to the Apple System Log facility.</p></blockquote><p>据我观察，现在有很多开发者都用 NSLog 来调试。**但是我觉得，一般的程序调试，用断点就好了，我不推荐你把 NSLog 作为一种调试手段。**因为，使用NSLog调试，会发生 IO 磁盘操作，当频繁使用 NSLog 时，性能就会变得不好。另外，各团队都使用 NSLog 来调试的话很容易就会刷屏，这样你也没有办法在控制台上快速、准确地找到你自己的调试信息。</p><p>而如果你需要汇总一段时间的调试日志的话，自己把这些日志写到一个文件里就好了。这样的话，你随便想要怎么看都行，也不会参杂其他人打的日志。</p><p>所以说 ，CocoaLumberjack 将 NSLog 设置为 Verbose ，在我看来 CocoaLumberjack 对 NSLog 的理解也不够准确。说完如何创建一个 DDLogMessage，接下来我们再看看<strong>如何通过 DDLog 使用 DDLogMessage 作为参数添加一条 ASL 日志</strong>。下面是 DDLog 记录 ASL 日志相关的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">DDLogMessage *logMessage = [[DDLogMessage alloc] initWithMessage:message level:_captureLevel flag:flag context:0 file:@&quot;DDASLLogCapture&quot; function:nil line:0 tag:nil option:0 timestamp:timeStamp];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    [DDLog log:async message:logMessage]</span></div></pre></div><p>到这里，通过ASL获取 NSLog 日志的过程你就应该很清楚了。你可以直接使用 CocoaLumberjack 这个库通过 [DDASLLogCapture start] 捕获所有 NSLog 的日志。</p><p>你现在已经清楚了CocoaLumberjack 的捕获原理和方法，如果不想引入这个第三方库的话，也可以按照它的思路写个简化版的工具出来，只要这个工具能够把日志记录下来，并且能够在出现问题的时候，把日志上传到服务器，方便我们进行问题的追踪和定位即可。</p><p>为了使日志更高效，更有组织，在 iOS 10 之后，使用了新的统一日志系统（Unified Logging System）来记录日志，全面取代 ASL的方式。以下是官方原话：</p><blockquote><p>Unified logging is available in iOS 10.0 and later, macOS 10.12 and later, tvOS 10.0 and later, and watchOS 3.0 and later, and supersedes ASL (Apple System Logger) and the Syslog APIs. Historically, log messages were written to specific locations on disk, such as /etc/system.log. The unified logging system stores messages in memory and in a data store, rather than writing to text-based log files.</p></blockquote><p>接下来，我们就看看iOS 10之后，如何来获取NSLog日志。</p><p>统一日志系统的方式，是把日志集中存放在内存和数据库里，并提供单一、高效和高性能的接口去获取系统所有级别的消息传递。</p><p>macOS 10.12 开始使用了统一日志系统，我们通过控制台应用程序或日志命令行工具，就可以查看到日志消息。</p><p>但是，新的统一日志系统没有 ASL 那样的接口可以让我们取出全部日志，所以<strong>为了兼容新的统一日志系统，你就需要对 NSLog 日志的输出进行重定向。</strong></p><p>对NSLog进行重定向，我们首先想到的就是采用 Hook 的方式。因为NSLog本身就是一个C函数，而不是 Objective-C方法，所以我们就可以使用 fishhook 来完成重定向的工作。具体的实现代码如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static void (&amp;orig_nslog)(NSString *format, ...);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    void redirect_nslog(NSString *format, ...) {</span></div><div class="token-line"><span class="token plain">        // 可以在这里先进行自己的处理</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        // 继续执行原 NSLog</span></div><div class="token-line"><span class="token plain">        va_list va;</span></div><div class="token-line"><span class="token plain">        va_start(va, format);</span></div><div class="token-line"><span class="token plain">        NSLogv(format, va);</span></div><div class="token-line"><span class="token plain">        va_end(va);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main(int argc, const char * argv[]) {</span></div><div class="token-line"><span class="token plain">        @autoreleasepool {</span></div><div class="token-line"><span class="token plain">            struct rebinding nslog_rebinding = {&quot;NSLog&quot;,redirect_nslog,(void*)&amp;orig_nslog};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            NSLog(@&quot;try redirect nslog %@,%d&quot;,@&quot;is that ok?&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return</span></div></pre></div><p>可以看到，我在上面这段代码中，利用了 fishhook 对方法的符号地址进行了重新绑定，从而只要是 NSLog 的调用就都会转向 redirect_nslog 方法调用。</p><p>在 redirect_nslog 方法中，你可以先进行自己的处理，比如将日志的输出重新输出到自己的持久化存储系统里，接着调用 NSLog 也会调用的 NSLogv 方法进行原 NSLog 方法的调用。当然了，你也可以使用 fishhook 提供的原方法调用方式 orig_nslog，进行原 NSLog 方法的调用。上面代码里也已经声明了类 orig_nslog，直接调用即可。</p><p>NSLog 最后写文件时的句柄是 STDERR，我先前跟你说了苹果对于 NSLog 的定义是记录错误的信息，STDERR 的全称是 standard error，系统错误日志都会通过 STDERR 句柄来记录，所以 NSLog 最终将错误日志进行写操作的时候也会使用 STDERR 句柄，而 dup2 函数是专门进行文件重定向的，那么也就有了另一个不使用 fishhook 还可以捕获 NSLog 日志的方法。你可以使用 dup2 重定向 STDERR 句柄，使得重定向的位置可以由你来控制，关键代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int fd = open(path, (O_RDWR | O_CREAT), 0644);</span></div><div class="token-line"><span class="token plain">    dup2(fd, STDERR_FILENO);</span></div></pre></div><p>其中，path 就是你自定义的重定向输出的文件地址。</p><p>这样，我们就能够获取到各个系统版本的 NSLog了。那么，通过其他方式打的日志，我们怎么才能获取到呢？</p><p>现在与日志相关的第三方库里面，使用最多的就是 CocoaLumberjack。而且，其他的很多第三库的思路也和CocoaLumberjack类似，都是直接在 CocoaLumberjack 的基础上包装了一层，增加了统一管控力和易用性而已。</p><p>接下来，我们就先看看 CocoaLumberjack 的整体架构是怎样的，进而找到获取 CocoaLumberjack 所有日志的方法。</p><h2 id="获取-cocoalumberjack-日志"><a aria-hidden="true" tabindex="-1" href="/blog/ios开发高手课/02.基础篇/15#获取-cocoalumberjack-日志"><span class="icon icon-link"></span></a>获取 CocoaLumberjack 日志</h2><p>CocoaLumberjack主要由DDLog、DDLoger、DDLogFormatter和DDLogMessage四部分组成，其整体架构如下图所示：<br/><img src="/images/ios%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/02.%E5%9F%BA%E7%A1%80%E7%AF%87/resourceimagefffbff12f684d74be1b901e2dede5b5ab5fb.png" alt=""/></p><p>在这其中，DDLog 是个全局的单例类，会保存 DDLogger 协议的 logger；DDLogFormatter 用来格式化日志的格式；DDLogMessage 是对日志消息的一个封装；DDLogger 协议是由 DDAbstractLogger 实现的。logger 都是继承于 DDAbstractLogger：</p><ul><li>日志输出到控制台是通过 DDTTYLogger实现的；</li><li>DDASLLogger 就是用来捕获 NSLog 记录到 ASL 数据库的日志；</li><li>DDAbstractDatabaseLogger是数据库操作的抽象接口；</li><li>DDFileLogger 是用来保存日志到文件的，还提供了返回 CocoaLumberjack 日志保存文件路径的方法，使用方法如下：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">DDFileLogger *fileLogger = [[DDFileLogger alloc] init];</span></div><div class="token-line"><span class="token plain">    NSString *logDirectory = [fileLogger.logFileManager logsDirectory];</span></div></pre></div><p>其中，logDirectory 方法可以获取日志文件的目录路径。有了目录以后，我们就可以获取到目录下所有的 CocoaLumberjack 的日志了，也就达到了我们要获取CocoaLumberjack 所有日志的目的。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/ios开发高手课/02.基础篇/15#小结"><span class="icon icon-link"></span></a>小结</h2><p>在今天这篇文章中，我和你介绍了 NSLog 和 CocoaLumberjack 日志的获取方法。这两种打日志的方式基本覆盖了大部分场景，你在使用其他日志库时，只要找到日志存储的目录，就可以进行日志的收集合并工作了。</p><p>收集全量日志，可以提高分析和解决问题的效率，节省下来的时间我们可以去做更有意义的事情。</p><p>在今天讲获取 NSLog 日志的过程中，你会发现为了达到获取 NSLog 日志的目的，方法有三个：</p><ul><li>第一个是使用官方提供的接口 ASL 来获取；</li><li>第二个是通过一招吃遍天下的 fishhook 来 hook 的方法；</li><li>第三个方法，需要用到 dup2 函数和 STDERR 句柄。我们只有了解了这些知识点后，才会想到这个方法。</li></ul><p>在第2篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/85331">App 启动速度怎么做优化与监控？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”里，我也提到过两个方案来实现启动监控。其中，第二个使用 hook objc_msgSend 方法的方案，看起来连汇编语言都用到了，应该没有更好的方案了吧，其实不然，我这里卖个关子，后面有机会我还会和你介绍另一个方案。</p><p>所以，我们接触的知识面越多，遇到问题时能想到的办法也就会越多。当出现意外时，就像是 ASL 在 iOS 10.0 之后不能用了这种情况下，你依然还能够有其他方法来解决问题。</p><h2 id="课后作业"><a aria-hidden="true" tabindex="-1" href="/blog/ios开发高手课/02.基础篇/15#课后作业"><span class="icon icon-link"></span></a>课后作业</h2><p>今天课程中提到了跨进程通知，那么接下来就请你写一个监听用户设备磁盘空间不够时，清理App 缓存文件的功能吧。</p><p>我今天还会再多布置一个作业。我在和你分析捕获 NSLog 日志时，提到了一个用dup2替换掉默认句柄的方法。所以，我希望你可以动手实践一下，按照这个思路将其完整实现出来吧。</p><p>感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎把它分享给更多的朋友一起阅读。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/ios开发高手课/02.基础篇/15.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 14:44:17</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
