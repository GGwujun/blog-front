<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>练习Sample跑起来 | 唯鹿同学的练习手记 第1辑 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/android开发高手课/06.练习sample跑起来/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础</span><span>算法<ul><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackchain">webpackchain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>移动端开发<ul><li><a aria-current="page" class="active" href="/blog/android开发高手课">android开发高手课</a></li><li><a href="/blog/ios开发高手课">ios开发高手课</a></li></ul></span><span>软件测试</span><span>产品与用户体验<ul><li><a href="/blog/视觉笔记入门课">视觉笔记入门课</a></li></ul></span><span>面试</span><span>杂谈<ul><li><a href="/blog/git实战手册">git实战手册</a></li><li><a href="/blog/nodejs">nodejs</a></li><li><a href="/blog/reactjs">reactjs</a></li><li><a href="/blog/ui设计">ui设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础</li><li>算法<ul><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackchain">webpackchain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>移动端开发<ul><li><a aria-current="page" class="active" href="/blog/android开发高手课">android开发高手课</a></li><li><a href="/blog/ios开发高手课">ios开发高手课</a></li></ul></li><li>软件测试</li><li>产品与用户体验<ul><li><a href="/blog/视觉笔记入门课">视觉笔记入门课</a></li></ul></li><li>面试</li><li>杂谈<ul><li><a href="/blog/git实战手册">git实战手册</a></li><li><a href="/blog/nodejs">nodejs</a></li><li><a href="/blog/reactjs">reactjs</a></li><li><a href="/blog/ui设计">ui设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/android开发高手课">android开发高手课</a></li><li><a href="/blog/android开发高手课/01.开篇词">01.开篇词</a><ul><li><a href="/blog/android开发高手课/01.开篇词/01"><span>开篇词 | 焦虑的移动开发者该如何破局？</span></a></li></ul></li><li><a href="/blog/android开发高手课/02.导读">02.导读</a><ul><li><a href="/blog/android开发高手课/02.导读/01"><span>导读 | 如何打造高质量的应用？</span></a></li></ul></li><li><a href="/blog/android开发高手课/03.模块一高质量开发">03.模块一高质量开发</a><ul><li><a href="/blog/android开发高手课/03.模块一高质量开发/01"><span>01 | 崩溃优化（上）：关于“崩溃”那些事儿</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/02"><span>02 | 崩溃优化（下）：应用崩溃了，你应该如何去分析？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/03"><span>03 | 内存优化（上）：4GB内存时代，再谈内存优化</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/04"><span>04 | 内存优化（下）：内存优化这件事，应该从哪里着手？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/05"><span>05 | 卡顿优化（上）：你要掌握的卡顿分析方法</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/06"><span>06 | 卡顿优化（下）：如何监控应用卡顿？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/07"><span>06补充篇 | 卡顿优化：卡顿现场与卡顿分析</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/08"><span>07 | 启动优化（上）：从启动过程看启动速度优化</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/09"><span>08 | 启动优化（下）：优化启动速度的进阶方法</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/10"><span>09 | I/O优化（上）：开发工程师必备的I/O优化知识</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/11"><span>10 | I/O优化（中）：不同I/O方式的使用场景是什么？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/12"><span>11 | I/O优化（下）：如何监控线上I/O操作？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/13"><span>12 | 存储优化（上）：常见的数据存储方法有哪些？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/14"><span>13 | 存储优化（中）：如何优化数据存储？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/15"><span>14 | 存储优化（下）：数据库SQLite的使用和优化</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/16"><span>15 | 网络优化（上）：移动开发工程师必备的网络优化知识</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/17"><span>16 | 网络优化（中）：复杂多变的移动网络该如何优化？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/18"><span>17 | 网络优化（下）：大数据下网络该如何监控？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/19"><span>18 | 耗电优化（上）：从电量优化的演进看耗电分析</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/20"><span>19 | 耗电优化（下）：耗电的优化方法与线上监控</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/21"><span>20 | UI 优化（上）：UI 渲染的几个关键概念</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/22"><span>21 | UI 优化（下）：如何优化 UI 渲染？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/23"><span>22 | 包体积优化（上）：如何减少安装包大小？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/24"><span>23 | 包体积优化（下）：资源优化的进阶实践</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/25"><span>24 | 想成为Android高手，你需要先搞定这三个问题</span></a></li></ul></li><li><a href="/blog/android开发高手课/04.模块二高效开发">04.模块二高效开发</a><ul><li><a href="/blog/android开发高手课/04.模块二高效开发/01"><span>25 | 如何提升组织与个人的研发效能？</span></a></li><li><a href="/blog/android开发高手课/04.模块二高效开发/02"><span>26 | 关于编译，你需要了解什么？</span></a></li><li><a href="/blog/android开发高手课/04.模块二高效开发/03"><span>27 | 编译插桩的三种方法：AspectJ、ASM、ReDex</span></a></li><li><a href="/blog/android开发高手课/04.模块二高效开发/04"><span>28 | 大数据与AI，如何高效地测试？</span></a></li><li><a href="/blog/android开发高手课/04.模块二高效开发/05"><span>29 | 从每月到每天，如何给版本发布提速？</span></a></li><li><a href="/blog/android开发高手课/04.模块二高效开发/06"><span>30 | 数据评估（上）：如何实现高可用的上报组件？</span></a></li><li><a href="/blog/android开发高手课/04.模块二高效开发/07"><span>31 | 数据评估（下）：什么是大数据平台？</span></a></li><li><a href="/blog/android开发高手课/04.模块二高效开发/08"><span>32 | 线上疑难问题该如何排查和跟踪？</span></a></li><li><a href="/blog/android开发高手课/04.模块二高效开发/09"><span>33 | 做一名有高度的移动开发工程师</span></a></li></ul></li><li><a href="/blog/android开发高手课/05.模块三架构演进">05.模块三架构演进</a><ul><li><a href="/blog/android开发高手课/05.模块三架构演进/01"><span>34 | 聊聊重构：优秀的架构都是演进而来的</span></a></li><li><a href="/blog/android开发高手课/05.模块三架构演进/02"><span>35 | Native Hook 技术，天使还是魔鬼？</span></a></li><li><a href="/blog/android开发高手课/05.模块三架构演进/03"><span>36 | 跨平台开发的现状与应用</span></a></li><li><a href="/blog/android开发高手课/05.模块三架构演进/04"><span>37 | 移动开发新大陆：工作三年半，移动开发转型手游开发</span></a></li><li><a href="/blog/android开发高手课/05.模块三架构演进/05"><span>38 | 移动开发新大陆：Android音视频开发</span></a></li><li><a href="/blog/android开发高手课/05.模块三架构演进/06"><span>39 | 移动开发新大陆： 边缘智能计算的趋势</span></a></li><li><a href="/blog/android开发高手课/05.模块三架构演进/07"><span>40 | 动态化实践，如何选择适合自己的方案？</span></a></li><li><a href="/blog/android开发高手课/05.模块三架构演进/08"><span>41 | 聊聊Flutter，面对层出不穷的新技术该如何跟进？</span></a></li><li><a href="/blog/android开发高手课/05.模块三架构演进/09"><span>42 | Android开发高手课学习心得</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/android开发高手课/06.练习sample跑起来">06.练习Sample跑起来</a><ul><li><a href="/blog/android开发高手课/06.练习sample跑起来/01"><span>练习Sample跑起来 | 热点问题答疑第1期</span></a></li><li><a href="/blog/android开发高手课/06.练习sample跑起来/02"><span>练习Sample跑起来 | 热点问题答疑第2期</span></a></li><li><a href="/blog/android开发高手课/06.练习sample跑起来/03"><span>练习Sample跑起来 | 热点问题答疑第3期</span></a></li><li><a href="/blog/android开发高手课/06.练习sample跑起来/04"><span>练习Sample跑起来 | 热点问题答疑第4期</span></a></li><li><a href="/blog/android开发高手课/06.练习sample跑起来/05"><span>练习Sample跑起来 | ASM插桩强化练习</span></a></li><li><a aria-current="page" class="active" href="/blog/android开发高手课/06.练习sample跑起来/06"><span>练习Sample跑起来 | 唯鹿同学的练习手记 第1辑</span></a></li><li><a href="/blog/android开发高手课/06.练习sample跑起来/07"><span>练习Sample跑起来 | 唯鹿同学的练习手记 第2辑</span></a></li><li><a href="/blog/android开发高手课/06.练习sample跑起来/08"><span>练习Sample跑起来 | 唯鹿同学的练习手记 第3辑</span></a></li></ul></li><li><a href="/blog/android开发高手课/07.特别放送">07.特别放送</a><ul><li><a href="/blog/android开发高手课/07.特别放送/01"><span>Android JVM TI机制详解（内含福利彩蛋）</span></a></li><li><a href="/blog/android开发高手课/07.特别放送/02"><span>专栏学得苦？可能是方法没找对</span></a></li><li><a href="/blog/android开发高手课/07.特别放送/03"><span>专栏学得苦？可能你还需要一份配套学习书单</span></a></li><li><a href="/blog/android开发高手课/07.特别放送/04"><span>Native下如何获取调用栈？</span></a></li><li><a href="/blog/android开发高手课/07.特别放送/05"><span>聊聊Framework的学习方法</span></a></li><li><a href="/blog/android开发高手课/07.特别放送/06"><span>Android工程师的“面试指南”</span></a></li><li><a href="/blog/android开发高手课/07.特别放送/07"><span>程序员修炼之路 | 设计能力的提升途径</span></a></li></ul></li><li><a href="/blog/android开发高手课/08.结束语">08.结束语</a><ul><li><a href="/blog/android开发高手课/08.结束语/01"><span>结束语 | 移动开发的今天和明天</span></a></li><li><a href="/blog/android开发高手课/08.结束语/02"><span>结课测试 | 这些Android知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog/android开发高手课/summary">android开发高手课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="练习sample跑起来--唯鹿同学的练习手记-第1辑"><a aria-hidden="true" tabindex="-1" href="/blog/android开发高手课/06.练习sample跑起来/06#练习sample跑起来--唯鹿同学的练习手记-第1辑"><span class="icon icon-link"></span></a>练习Sample跑起来 | 唯鹿同学的练习手记 第1辑</h1><blockquote><p>你好，我是张绍文，今天我要跟你分享唯鹿同学完成专栏课后练习作业的“手记”。专栏承诺会为坚持完成练习作业的同学送出GMTC大会门票，唯鹿同学通过自己的努力和坚持，为自己赢得了GMTC大会的门票。</p><p>如果你还没开始练习，我强烈建议你花一些时间在练习上，因为每个练习的Sample都是我和学习委员花费很多精力精心准备的，为的是让你在学习完后可以有机会上手实践，帮你尽快消化专栏里的知识并为自己所用。</p></blockquote><p>大家好，我是唯鹿，来自西安，从事Android开发也有近5年的时间了，目前在做智慧社区方面的业务。我自己坚持写博客已经有三年多的时间了，希望分享自己在工作、学习中的收获。</p><p>先说说我学习专栏的方法，专栏更新当天我就会去学习，但是难度真的不小。我对自己的要求并不是看一遍就要搞明白，而是遇见不懂的地方立马查阅资料，要做到大体了解整篇内容。之后在周末的时候我会集中去做Sample练习，一边复习本周发布的内容，一边用写博客的方式记录练习的结果。</p><p>后面我计划专栏结束后再多看、多练习几遍，不断查漏补缺。说真的，我很喜欢《Android开发高手课》的难度，让我在完成练习作业时有种翻越高山的快感。最后，希望同学们一起坚持，享受翻越高山带来的成就感。</p><hr/><p>最近在学习张绍文老师的《Android开发高手课》。课后作业可不是一般的难，最近几天抽空练习了一下，结合老师给的步骤和其他同学的经验，完成了前5课的内容。</p><p>我整理总结了一下，分享出来，希望可以帮到一起学习的同学（当然希望大家尽量靠自己解决问题）。</p><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/AndroidAdvanceWithGeektime/Chapter01"><strong>Chapter01</strong></a></p><blockquote><p>例子里集成了Breakpad来获取发生Native Crash时候的系统信息和线程堆栈信息。通过一个简单的Native崩溃捕获过程，完成minidump文件的生成和解析，在实践中加深对Breakpad工作机制的认识。</p></blockquote><p>直接运行项目，按照README.md的步骤操作就行。</p><p>中间有个问题，老师提供的minidump_stackwalker工具在macOS 10.14以上无法成功执行，因为没有libstdc++.6.dylib库，所以我就下载Breakpad源码重新编译了一遍。</p><p>使用minidump_stackwalker工具来根据minidump文件生成堆栈跟踪log，得到的crashLog.txt文件如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Operating system: Android</span></div><div class="token-line"><span class="token plain">                      0.0.0 Linux 4.9.112-perf-gb92eddd #1 SMP PREEMPT Tue Jan 1 21:35:06 CST 2019 aarch64</span></div><div class="token-line"><span class="token plain">    CPU: arm64  // 注意点1</span></div><div class="token-line"><span class="token plain">         8 CPUs</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    GPU: UNKNOWN</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Crash reason:  SIGSEGV /SEGV_MAPERR</span></div><div class="token-line"><span class="token plain">    Crash address: 0x0</span></div><div class="token-line"><span class="token plain">    Process uptime: not available</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Thread 0 (crashed)</span></div><div class="token-line"><span class="token plain">     0  libcrash-lib.so + 0x600 // 注意点2</span></div><div class="token-line"><span class="token plain">         x0 = 0x00000078e0ce8460    x1 = 0x0000007fd4000314</span></div><div class="token-line"><span class="token plain">         x2 = 0x0000007fd40003b0    x3 = 0x00000078e0237134</span></div><div class="token-line"><span class="token plain">         x4 = 0x0000007fd40005d0    x5 = 0x00000078dca14200</span></div><div class="token-line"><span class="token plain">         x6 = 0x0000007fd4000160    x7 = 0x00000078c8987e18</span></div><div class="token-line"><span class="token plain">         x8 = 0x0000000000000000    x9 = 0x0000000000000001</span></div><div class="token-line"><span class="token plain">        x10 = 0x0000000000430000   x11 = 0x00000078e05ef688</span></div><div class="token-line"><span class="token plain">        x12 = 0x00000079664ab050   x13 = 0x0ad046ab5a65bfdf</span></div><div class="token-line"><span class="token plain">        x14 = 0x000000796650c000   x15 = 0xffffffffffffffff</span></div><div class="token-line"><span class="token plain">        x16 = 0x00000078c83defe8   x17 = 0x00000078c83ce5ec</span></div><div class="token-line"><span class="token plain">        x18 = 0x0000000000000001   x19 = 0x00000078e0c14c00</span></div><div class="token-line"><span class="token plain">        x20 = 0x0000000000000000   x21 = 0x00000078e0c14c00</span></div><div class="token-line"><span class="token plain">        x22 = 0x0000007fd40005e0   x23 = 0x00000078c89fa661</span></div><div class="token-line"><span class="token plain">        x24 = 0x0000000000000004   x25 = 0x00000079666cc5e0</span></div><div class="token-line"><span class="token plain">        x26 = 0x00000078e0c14ca0   x27 = 0x0000000000000001</span></div><div class="token-line"><span class="token plain">        x28 = 0x0000007fd4000310    fp = 0x0000007fd40002e0</span></div><div class="token-line"><span class="token plain">         lr = 0x00000078c83ce624    sp = 0x0000007fd40002c0</span></div><div class="token-line"><span class="token plain">         pc = 0x00000078c83ce600</span></div><div class="token-line"><span class="token plain">        Found by: given as instruction pointer in context</span></div><div class="token-line"><span class="token plain">     1  libcrash-lib.so + 0x620</span></div><div class="token-line"><span class="token plain">         fp = 0x0000007fd4000310    lr = 0x00000078e051c7e4</span></div><div class="token-line"><span class="token plain">         sp = 0x0000007fd40002f0    pc = 0x00000078c83ce624</span></div><div class="token-line"><span class="token plain">        Found by: previous frame&#x27;s frame pointer</span></div><div class="token-line"><span class="token plain">     2  libart.so + 0x55f7e0</span></div><div class="token-line"><span class="token plain">         fp = 0x130c0cf800000001    lr = 0x00000079666cc5e0</span></div><div class="token-line"><span class="token plain">         sp = 0x0000007fd4000320    pc = 0x00000078e051c7e4</span></div><div class="token-line"><span class="token plain">        Found by: previous frame&#x27;s frame pointer</span></div><div class="token-line"><span class="token plain">    ......</span></div></pre></div><p>下来是符号解析，可以使用NDK中提供的<code>addr2line</code>来根据地址进行一个符号反解的过程，该工具在<code>$NDK_HOME/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-addr2line</code>。</p><p>注意：此处要注意一下平台，如果是ARM 64位的so，解析是需要使用aarch64-linux-android-4.9下的工具链。</p><p>因为我的是ARM 64位的so。所以使用aarch64-linux-android-4.9，libcrash-lib.so在<code>app/build/intermediates/cmake/debug/obj/arm64-v8a</code>下，<code>0x600</code>为错误位置符号。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">aarch64-linux-android-addr2line -f -C -e libcrash-lib.so 0x600</span></div></pre></div><p>输出结果如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Crash()</span></div><div class="token-line"><span class="token plain">    /Users/weilu/Downloads/Chapter01-master/sample/.externalNativeBuild/cmake/debug/arm64-v8a/../../../../src/main/cpp/crash.cpp:10</span></div></pre></div><p>可以看到输出结果与下图错误位置一致（第10行）。</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/06.%E7%BB%83%E4%B9%A0Sample%E8%B7%91%E8%B5%B7%E6%9D%A5/resourceimageffabffbea53bc34d05c02055f1e348594dab.png" alt=""/></p><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/AndroidAdvanceWithGeektime/Chapter02"><strong>Chapter02</strong></a></p><blockquote><p>该例子主要演示了如何通过关闭FinalizerWatchdogDaemon来减少TimeoutException的触发。</p></blockquote><p>在我的上一篇博客：<a target="_blank" rel="noopener noreferrer" href="https://blog.csdn.net/qq_17766199/article/details/84789495#t1">安卓开发中遇到的奇奇怪怪的问题（三）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中有说明，就不重复赘述了。</p><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/AndroidAdvanceWithGeektime/Chapter03"><strong>Chapter03</strong></a></p><blockquote><p>项目使用了Inline Hook来拦截内存对象分配时候的RecordAllocation函数，通过拦截该接口可以快速获取到当时分配对象的类名和分配的内存大小。</p><p>在初始化的时候我们设置了一个分配对象数量的最大值，如果从start开始对象分配数量超过最大值就会触发内存dump，然后清空alloc对象列表，重新计算。该功能和Android Studio里的Allocation Tracker类似，只不过可以在代码级别更细粒度的进行控制。可以精确到方法级别。</p></blockquote><p>项目直接跑起来后，点击开始记录，然后点击5次生成1000对象按钮。生成对象代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for (int i = 0; i &lt; 1000; i++) {</span></div><div class="token-line"><span class="token plain">         Message msg = new Message();</span></div><div class="token-line"><span class="token plain">         msg.what = i;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>因为代码从点击开始记录开始，触发到5000的数据就dump到文件中，点击5次后就会在<code>sdcard/crashDump</code>下生成一个时间戳命名的文件。项目根目录下调用命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">java -jar tools/DumpPrinter-1.0.jar dump文件路径 &gt; dump_log.txt</span></div></pre></div><p>然后就可以在dump_log.txt中看到解析出来的数据：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Found 5000 records:</span></div><div class="token-line"><span class="token plain">    ....</span></div><div class="token-line"><span class="token plain">    tid=4509 android.graphics.drawable.RippleForeground (112 bytes)</span></div><div class="token-line"><span class="token plain">        android.graphics.drawable.RippleDrawable.tryRippleEnter (RippleDrawable.java:569)</span></div><div class="token-line"><span class="token plain">        android.graphics.drawable.RippleDrawable.setRippleActive (RippleDrawable.java:276)</span></div><div class="token-line"><span class="token plain">        android.graphics.drawable.RippleDrawable.onStateChange (RippleDrawable.java:266)</span></div><div class="token-line"><span class="token plain">        android.graphics.drawable.Drawable.setState (Drawable.java:778)</span></div><div class="token-line"><span class="token plain">        android.view.View.drawableStateChanged (View.java:21137)</span></div><div class="token-line"><span class="token plain">        android.widget.TextView.drawableStateChanged (TextView.java:5289)</span></div><div class="token-line"><span class="token plain">        android.support.v7.widget.AppCompatButton.drawableStateChanged (AppCompatButton.java:155)</span></div><div class="token-line"><span class="token plain">        android.view.View.refreshDrawableState (View.java:21214)</span></div><div class="token-line"><span class="token plain">        android.view.View.setPressed (View.java:10583)</span></div><div class="token-line"><span class="token plain">        android.view.View.setPressed (View.java:10561)</span></div><div class="token-line"><span class="token plain">        android.view.View.onTouchEvent (View.java:13865)</span></div><div class="token-line"><span class="token plain">        android.widget.TextView.onTouchEvent (TextView.java:10070)</span></div><div class="token-line"><span class="token plain">        android.view.View.dispatchTouchEvent (View.java:12533)</span></div><div class="token-line"><span class="token plain">        android.view.ViewGroup.dispatchTransformedTouchEvent (ViewGroup.java:3032)</span></div><div class="token-line"><span class="token plain">        android.view.ViewGroup.dispatchTouchEvent (ViewGroup.java:2662)</span></div><div class="token-line"><span class="token plain">        android.view.ViewGroup.dispatchTransformedTouchEvent (ViewGroup.java:3032)</span></div><div class="token-line"><span class="token plain">    tid=4515 int[] (104 bytes)</span></div><div class="token-line"><span class="token plain">    tid=4509 android.os.BaseLooper$MessageMonitorInfo (88 bytes)</span></div><div class="token-line"><span class="token plain">        android.os.Message.&lt;init&gt; (Message.java:123)</span></div><div class="token-line"><span class="token plain">        com.dodola.alloctrack.MainActivity$4.onClick (MainActivity.java:70)</span></div><div class="token-line"><span class="token plain">        android.view.View.performClick (View.java:6614)</span></div><div class="token-line"><span class="token plain">        android.view.View.performClickInternal (View.java:6591)</span></div><div class="token-line"><span class="token plain">        android.view.View.access$3100 (View.java:786)</span></div><div class="token-line"><span class="token plain">        android.view.View$PerformClick.run (View.java:25948)</span></div><div class="token-line"><span class="token plain">        android.os.Handler.handleCallback (Handler.java:873)</span></div><div class="token-line"><span class="token plain">        android.os.Handler.dispatchMessage (Handler.java:99)</span></div><div class="token-line"><span class="token plain">        android.os.Looper.loop (Looper.java:201)</span></div><div class="token-line"><span class="token plain">        android.app.ActivityThread.main (ActivityThread.java:6806)</span></div><div class="token-line"><span class="token plain">        java.lang.reflect.Method.invoke (Native method)</span></div><div class="token-line"><span class="token plain">        com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run (RuntimeInit.java:547)</span></div><div class="token-line"><span class="token plain">        com.android.internal.os.ZygoteInit.main (ZygoteInit.java:873)</span></div><div class="token-line"><span class="token plain">    ......</span></div></pre></div><p>我们用Android Profiler查找一个Message对象对比一下，一模一样。</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/06.%E7%BB%83%E4%B9%A0Sample%E8%B7%91%E8%B5%B7%E6%9D%A5/resourceimageea10ea9e03f90bc15a086d523958272fe410.png" alt=""/></p><p>简单看一下Hook代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void hookFunc() {</span></div><div class="token-line"><span class="token plain">        LOGI(&quot;start hookFunc&quot;);</span></div><div class="token-line"><span class="token plain">        void *handle = ndk_dlopen(&quot;libart.so&quot;, RTLD_LAZY | RTLD_GLOBAL);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if (!handle) {</span></div><div class="token-line"><span class="token plain">            LOGE(&quot;libart.so open fail&quot;);</span></div><div class="token-line"><span class="token plain">            return;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        void *hookRecordAllocation26 = ndk_dlsym(handle,</span></div><div class="token-line"><span class="token plain">                                                 &quot;_ZN3art2gc20AllocRecordObjectMap16RecordAllocationEPNS_6ThreadEPNS_6ObjPtrINS_6mirror6ObjectEEEj&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        void *hookRecordAllocation24 = ndk_dlsym(handle,</span></div><div class="token-line"><span class="token plain">                                                 &quot;_ZN3art2gc20AllocRecordObjectMap16RecordAllocationEPNS_6ThreadEPPNS_6mirror6ObjectEj&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        void *hookRecordAllocation23 = ndk_dlsym(handle,</span></div><div class="token-line"><span class="token plain">                                                 &quot;_ZN3art3Dbg16RecordAllocationEPNS_6ThreadEPNS_6mirror5ClassEj&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        void *hookRecordAllocation22 = ndk_dlsym(handle,</span></div><div class="token-line"><span class="token plain">                                                 &quot;_ZN3art3Dbg16RecordAllocationEPNS_6mirror5ClassEj&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if (hookRecordAllocation26 != nullptr) {</span></div><div class="token-line"><span class="token plain">            LOGI(&quot;Finish get symbol26&quot;);</span></div><div class="token-line"><span class="token plain">            MSHookFunction(hookRecordAllocation26, (void *) &amp;newArtRecordAllocation26,</span></div><div class="token-line"><span class="token plain">                           (void **) &amp;oldArtRecordAllocation26);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        } else if (hookRecordAllocation24 != nullptr) {</span></div><div class="token-line"><span class="token plain">            LOGI(&quot;Finish get symbol24&quot;);</span></div><div class="token-line"><span class="token plain">            MSHookFunction(hookRecordAllocation26, (void *) &amp;newArtRecordAllocation26,</span></div><div class="token-line"><span class="token plain">                           (void **) &amp;oldArtRecordAllocation26);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        } else if (hookRecordAllocation23 != NULL) {</span></div><div class="token-line"><span class="token plain">            LOGI(&quot;Finish get symbol23&quot;);</span></div><div class="token-line"><span class="token plain">            MSHookFunction(hookRecordAllocation23, (void *) &amp;newArtRecordAllocation23,</span></div><div class="token-line"><span class="token plain">                           (void **) &amp;oldArtRecordAllocation23);</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">            LOGI(&quot;Finish get symbol22&quot;);</span></div><div class="token-line"><span class="token plain">            if (hookRecordAllocation22 == NULL) {</span></div><div class="token-line"><span class="token plain">                LOGI(&quot;error find hookRecordAllocation22&quot;);</span></div><div class="token-line"><span class="token plain">                return;</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">                MSHookFunction(hookRecordAllocation22, (void *) &amp;newArtRecordAllocation22,</span></div><div class="token-line"><span class="token plain">                               (void **) &amp;oldArtRecordAllocation22);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        dlclose(handle);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>使用了Inline Hook方案Substrate来拦截内存对象分配时候libart.so的RecordAllocation函数。首先如果我们要hook一个函数，需要知道这个函数的地址。我们也看到了代码中这个地址判断了四种不同系统。这里有一个<a target="_blank" rel="noopener noreferrer" href="http://demangler.com/">网页版的解析工具<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>可以快速获取。下面以8.0为例。</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/06.%E7%BB%83%E4%B9%A0Sample%E8%B7%91%E8%B5%B7%E6%9D%A5/resourceimage890889bc383aab02af0b71d243dc10273708.png" alt=""/></p><p>我在8.0的源码中找到了对应的方法：</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/06.%E7%BB%83%E4%B9%A0Sample%E8%B7%91%E8%B5%B7%E6%9D%A5/resourceimagea126a1655f62725d8ae28a14ed717860e726.jpeg" alt=""/></p><p>7.0方法就明显不同：</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/06.%E7%BB%83%E4%B9%A0Sample%E8%B7%91%E8%B5%B7%E6%9D%A5/resourceimage3a253a2e76c476c6a21e6036022793521925.jpeg" alt=""/></p><p>我也同时参看了9.0的代码，发现没有变化，所以我的测试机是9.0的也没有问题。</p><p>Hook新内存对象分配处理代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static bool newArtRecordAllocationDoing24(Class *type, size_t byte_count) {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        allocObjectCount++;</span></div><div class="token-line"><span class="token plain">    	//根据 class 获取类名</span></div><div class="token-line"><span class="token plain">        char *typeName = GetDescriptor(type, &amp;a);</span></div><div class="token-line"><span class="token plain">        //达到 max</span></div><div class="token-line"><span class="token plain">        if (allocObjectCount &gt; setAllocRecordMax) {</span></div><div class="token-line"><span class="token plain">            CMyLock lock(g_Lock);//此处需要 loc 因为对象分配的时候不知道在哪个线程，不 lock 会导致重复 dump</span></div><div class="token-line"><span class="token plain">            allocObjectCount = 0;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // dump alloc 里的对象转换成 byte 数据</span></div><div class="token-line"><span class="token plain">            jbyteArray allocData = getARTAllocationData();</span></div><div class="token-line"><span class="token plain">            // 将alloc数据写入文件</span></div><div class="token-line"><span class="token plain">            SaveAllocationData saveData{allocData};</span></div><div class="token-line"><span class="token plain">            saveARTAllocationData(saveData);</span></div><div class="token-line"><span class="token plain">            resetARTAllocRecord();</span></div><div class="token-line"><span class="token plain">            LOGI(&quot;===========CLEAR ALLOC MAPS=============&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            lock.Unlock();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return true;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/AndroidAdvanceWithGeektime/Chapter04"><strong>Chapter04</strong></a></p><blockquote><p>通过分析内存文件hprof快速判断内存中是否存在重复的图片，并且将这些重复图片的PNG、堆栈等信息输出。</p></blockquote><p>首先是获取我们需要分析的hprof文件，我们加载两张相同的图片：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(), R.mipmap.test);</span></div><div class="token-line"><span class="token plain">     Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(), R.mipmap.test);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">     imageView1.setImageBitmap(bitmap1);</span></div><div class="token-line"><span class="token plain">     imageView2.setImageBitmap(bitmap2);</span></div></pre></div><p>生成hprof文件</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 手动触发GC</span></div><div class="token-line"><span class="token plain">     Runtime.getRuntime().gc();</span></div><div class="token-line"><span class="token plain">     System.runFinalization();</span></div><div class="token-line"><span class="token plain">     Debug.dumpHprofData(file.getAbsolutePath());</span></div></pre></div><p>接下来就是利用<a target="_blank" rel="noopener noreferrer" href="https://github.com/square/haha">HAHA库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>进行文件分析的核心代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 打开hprof文件</span></div><div class="token-line"><span class="token plain">    final HeapSnapshot heapSnapshot = new HeapSnapshot(hprofFile);</span></div><div class="token-line"><span class="token plain">    // 获得snapshot</span></div><div class="token-line"><span class="token plain">    final Snapshot snapshot = heapSnapshot.getSnapshot();</span></div><div class="token-line"><span class="token plain">    // 获得Bitmap Class</span></div><div class="token-line"><span class="token plain">    final ClassObj bitmapClass = snapshot.findClass(&quot;android.graphics.Bitmap&quot;);</span></div><div class="token-line"><span class="token plain">    // 获得heap, 只需要分析app和default heap即可</span></div><div class="token-line"><span class="token plain">    Collection&lt;Heap&gt; heaps = snapshot.getHeaps();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    for (Heap heap : heaps) {</span></div><div class="token-line"><span class="token plain">        // 只需要分析app和default heap即可</span></div><div class="token-line"><span class="token plain">        if (!heap.getName().equals(&quot;app&quot;) &amp;&amp; !heap.getName().equals(&quot;default&quot;)) {</span></div><div class="token-line"><span class="token plain">            continue;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        for (ClassObj clazz : bitmapClasses) {</span></div><div class="token-line"><span class="token plain">            //从heap中获得所有的Bitmap实例</span></div><div class="token-line"><span class="token plain">            List&lt;Instance&gt; bitmapInstances = clazz.getHeapInstances(heap.getId());</span></div><div class="token-line"><span class="token plain">    		//从Bitmap实例中获得buffer数组,宽高信息等。</span></div><div class="token-line"><span class="token plain">            ArrayInstance buffer = HahaHelper.fieldValue(((ClassInstance) bitmapInstance).getValues(), &quot;mBuffer&quot;);</span></div><div class="token-line"><span class="token plain">            int bitmapHeight = fieldValue(bitmapInstance, &quot;mHeight&quot;);</span></div><div class="token-line"><span class="token plain">            int bitmapWidth = fieldValue(bitmapInstance, &quot;mWidth&quot;);</span></div><div class="token-line"><span class="token plain">            // 引用链信息</span></div><div class="token-line"><span class="token plain">            while (bitmapInstance.getNextInstanceToGcRoot() != null) {</span></div><div class="token-line"><span class="token plain">                print(instance.getNextInstanceToGcRoot());</span></div><div class="token-line"><span class="token plain">                instance = instance.getNextInstanceToGcRoot();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            // 根据hashcode来进行重复判断</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>最终的输出结果：</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/06.%E7%BB%83%E4%B9%A0Sample%E8%B7%91%E8%B5%B7%E6%9D%A5/resourceimage969c963f4a3cabf8ef5aa4faa0a61c55bd9c.jpeg" alt=""/></p><p>我们用Studio打开hprof文件对比一下：</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/06.%E7%BB%83%E4%B9%A0Sample%E8%B7%91%E8%B5%B7%E6%9D%A5/resourceimage0455049c6beae610971175f7521bcf4f8b55.jpeg" alt=""/></p><p>可以看到信息是一摸一样的。对于更优处理引用链的信息，可以参看<a target="_blank" rel="noopener noreferrer" href="https://github.com/square/leakcanary">LeakCanary<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>源码的实现。</p><p>我已经将上面的代码打成JAR包，可以直接调用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//调用方法：</span></div><div class="token-line"><span class="token plain">    java -jar tools/DuplicatedBitmapAnalyzer-1.0.jar hprof文件路径</span></div></pre></div><p>详细的代码我提交到了<a target="_blank" rel="noopener noreferrer" href="https://github.com/simplezhli/Chapter04">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，供大家参考。</p><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/AndroidAdvanceWithGeektime/Chapter05"><strong>Chapter05</strong></a></p><blockquote><p>尝试模仿<a target="_blank" rel="noopener noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/com/android/internal/os/ProcessCpuTracker.java">ProcessCpuTracker.java<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>拿到一段时间内各个线程的耗时占比。</p></blockquote><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">usage: CPU usage 5000ms(from 23:23:33.000 to 23:23:38.000):</span></div><div class="token-line"><span class="token plain">     System TOTAL: 2.1% user + 16% kernel + 9.2% iowait + 0.2% irq + 0.1% softirq + 72% idle</span></div><div class="token-line"><span class="token plain">     CPU Core: 8</span></div><div class="token-line"><span class="token plain">     Load Average: 8.74 / 7.74 / 7.36</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">     Process:com.sample.app </span></div><div class="token-line"><span class="token plain">       50% 23468/com.sample.app(S): 11% user + 38% kernel faults:4965</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">     Threads:</span></div><div class="token-line"><span class="token plain">       43% 23493/singleThread(R): 6.5% user + 36% kernel faults：3094</span></div><div class="token-line"><span class="token plain">       3.2% 23485/RenderThread(S): 2.1% user + 1% kernel faults：329</span></div><div class="token-line"><span class="token plain">       0.3% 23468/.sample.app(S): 0.3% user + 0% kernel faults：6</span></div><div class="token-line"><span class="token plain">       0.3% 23479/HeapTaskDaemon(S): 0.3% user + 0% kernel faults：982</span></div><div class="token-line"><span class="token plain">      ...</span></div></pre></div><p>因为了解Linux不多，所以看这个有点懵逼。好在课代表孙鹏飞同学解答了相关问题，看懂了上面信息，同时学习到了一些Linux知识。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private void testIO() {</span></div><div class="token-line"><span class="token plain">            Thread thread = new Thread(new Runnable() {</span></div><div class="token-line"><span class="token plain">                @Override</span></div><div class="token-line"><span class="token plain">                public void run() {</span></div><div class="token-line"><span class="token plain">                    File f = new File(getFilesDir(), &quot;aee.txt&quot;);</span></div><div class="token-line"><span class="token plain">    				FileOutputStream fos = new FileOutputStream(f);</span></div><div class="token-line"><span class="token plain">    				byte[] data = new byte[1024 * 4 * 3000];// 此处分配一个 12mb 大小的 byte 数组</span></div><div class="token-line"><span class="token plain">    	</span></div><div class="token-line"><span class="token plain">    				for (int i = 0; i &lt; 30; i++) {// 由于 IO cache 机制的原因所以此处写入多次 cache，触发 dirty writeback 到磁盘中</span></div><div class="token-line"><span class="token plain">        				Arrays.fill(data, (byte) i);// 当执行到此处的时候产生 minor fault，并且产生 User cpu useage</span></div><div class="token-line"><span class="token plain">        				fos.write(data);</span></div><div class="token-line"><span class="token plain">    				}</span></div><div class="token-line"><span class="token plain">    				fos.flush();</span></div><div class="token-line"><span class="token plain">    				fos.close();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            });</span></div><div class="token-line"><span class="token plain">            thread.setName(&quot;SingleThread&quot;);</span></div><div class="token-line"><span class="token plain">            thread.start();</span></div><div class="token-line"><span class="token plain">        }</span></div></pre></div><p>上述代码就是导致的问题罪魁祸首，这种密集I/O操作集中在SingleThread线程中处理，导致发生了3094次faults、36% kernel，完全没有很好利用到8核CPU。</p><p>最后，通过检测CPU的使用率，可以更好地避免卡顿现象，防止ANR的发生。</p><p>前前后后用了两三天的时间，远远没有当初想的顺利，感觉身体被掏空。中间也爬了不少坑，虽然没有太深入实现代码，但是中间的体验过程也是收获不小。所以总不能因为难就放弃了，先做到力所能及的部分，让自己动起来！</p><p><strong>参考</strong></p><ul><li><p><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/73068">练习Sample跑起来 | 热点问题答疑第1期<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/75440">练习Sample跑起来 | 热点问题答疑第2期<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li></ul></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/android开发高手课/06.练习Sample跑起来/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 14:47:42</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
