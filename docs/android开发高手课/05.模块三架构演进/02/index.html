<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>35 | Native Hook 技术，天使还是魔鬼？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/android开发高手课/05.模块三架构演进/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础</span><span>算法<ul><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackchain">webpackchain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>移动端开发<ul><li><a aria-current="page" class="active" href="/blog/android开发高手课">android开发高手课</a></li><li><a href="/blog/ios开发高手课">ios开发高手课</a></li></ul></span><span>软件测试</span><span>产品与用户体验<ul><li><a href="/blog/视觉笔记入门课">视觉笔记入门课</a></li></ul></span><span>面试</span><span>杂谈<ul><li><a href="/blog/git实战手册">git实战手册</a></li><li><a href="/blog/nodejs">nodejs</a></li><li><a href="/blog/reactjs">reactjs</a></li><li><a href="/blog/ui设计">ui设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础</li><li>算法<ul><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackchain">webpackchain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>移动端开发<ul><li><a aria-current="page" class="active" href="/blog/android开发高手课">android开发高手课</a></li><li><a href="/blog/ios开发高手课">ios开发高手课</a></li></ul></li><li>软件测试</li><li>产品与用户体验<ul><li><a href="/blog/视觉笔记入门课">视觉笔记入门课</a></li></ul></li><li>面试</li><li>杂谈<ul><li><a href="/blog/git实战手册">git实战手册</a></li><li><a href="/blog/nodejs">nodejs</a></li><li><a href="/blog/reactjs">reactjs</a></li><li><a href="/blog/ui设计">ui设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/android开发高手课">android开发高手课</a></li><li><a href="/blog/android开发高手课/01.开篇词">01.开篇词</a><ul><li><a href="/blog/android开发高手课/01.开篇词/01"><span>开篇词 | 焦虑的移动开发者该如何破局？</span></a></li></ul></li><li><a href="/blog/android开发高手课/02.导读">02.导读</a><ul><li><a href="/blog/android开发高手课/02.导读/01"><span>导读 | 如何打造高质量的应用？</span></a></li></ul></li><li><a href="/blog/android开发高手课/03.模块一高质量开发">03.模块一高质量开发</a><ul><li><a href="/blog/android开发高手课/03.模块一高质量开发/01"><span>01 | 崩溃优化（上）：关于“崩溃”那些事儿</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/02"><span>02 | 崩溃优化（下）：应用崩溃了，你应该如何去分析？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/03"><span>03 | 内存优化（上）：4GB内存时代，再谈内存优化</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/04"><span>04 | 内存优化（下）：内存优化这件事，应该从哪里着手？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/05"><span>05 | 卡顿优化（上）：你要掌握的卡顿分析方法</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/06"><span>06 | 卡顿优化（下）：如何监控应用卡顿？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/07"><span>06补充篇 | 卡顿优化：卡顿现场与卡顿分析</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/08"><span>07 | 启动优化（上）：从启动过程看启动速度优化</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/09"><span>08 | 启动优化（下）：优化启动速度的进阶方法</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/10"><span>09 | I/O优化（上）：开发工程师必备的I/O优化知识</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/11"><span>10 | I/O优化（中）：不同I/O方式的使用场景是什么？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/12"><span>11 | I/O优化（下）：如何监控线上I/O操作？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/13"><span>12 | 存储优化（上）：常见的数据存储方法有哪些？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/14"><span>13 | 存储优化（中）：如何优化数据存储？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/15"><span>14 | 存储优化（下）：数据库SQLite的使用和优化</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/16"><span>15 | 网络优化（上）：移动开发工程师必备的网络优化知识</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/17"><span>16 | 网络优化（中）：复杂多变的移动网络该如何优化？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/18"><span>17 | 网络优化（下）：大数据下网络该如何监控？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/19"><span>18 | 耗电优化（上）：从电量优化的演进看耗电分析</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/20"><span>19 | 耗电优化（下）：耗电的优化方法与线上监控</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/21"><span>20 | UI 优化（上）：UI 渲染的几个关键概念</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/22"><span>21 | UI 优化（下）：如何优化 UI 渲染？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/23"><span>22 | 包体积优化（上）：如何减少安装包大小？</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/24"><span>23 | 包体积优化（下）：资源优化的进阶实践</span></a></li><li><a href="/blog/android开发高手课/03.模块一高质量开发/25"><span>24 | 想成为Android高手，你需要先搞定这三个问题</span></a></li></ul></li><li><a href="/blog/android开发高手课/04.模块二高效开发">04.模块二高效开发</a><ul><li><a href="/blog/android开发高手课/04.模块二高效开发/01"><span>25 | 如何提升组织与个人的研发效能？</span></a></li><li><a href="/blog/android开发高手课/04.模块二高效开发/02"><span>26 | 关于编译，你需要了解什么？</span></a></li><li><a href="/blog/android开发高手课/04.模块二高效开发/03"><span>27 | 编译插桩的三种方法：AspectJ、ASM、ReDex</span></a></li><li><a href="/blog/android开发高手课/04.模块二高效开发/04"><span>28 | 大数据与AI，如何高效地测试？</span></a></li><li><a href="/blog/android开发高手课/04.模块二高效开发/05"><span>29 | 从每月到每天，如何给版本发布提速？</span></a></li><li><a href="/blog/android开发高手课/04.模块二高效开发/06"><span>30 | 数据评估（上）：如何实现高可用的上报组件？</span></a></li><li><a href="/blog/android开发高手课/04.模块二高效开发/07"><span>31 | 数据评估（下）：什么是大数据平台？</span></a></li><li><a href="/blog/android开发高手课/04.模块二高效开发/08"><span>32 | 线上疑难问题该如何排查和跟踪？</span></a></li><li><a href="/blog/android开发高手课/04.模块二高效开发/09"><span>33 | 做一名有高度的移动开发工程师</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/android开发高手课/05.模块三架构演进">05.模块三架构演进</a><ul><li><a href="/blog/android开发高手课/05.模块三架构演进/01"><span>34 | 聊聊重构：优秀的架构都是演进而来的</span></a></li><li><a aria-current="page" class="active" href="/blog/android开发高手课/05.模块三架构演进/02"><span>35 | Native Hook 技术，天使还是魔鬼？</span></a></li><li><a href="/blog/android开发高手课/05.模块三架构演进/03"><span>36 | 跨平台开发的现状与应用</span></a></li><li><a href="/blog/android开发高手课/05.模块三架构演进/04"><span>37 | 移动开发新大陆：工作三年半，移动开发转型手游开发</span></a></li><li><a href="/blog/android开发高手课/05.模块三架构演进/05"><span>38 | 移动开发新大陆：Android音视频开发</span></a></li><li><a href="/blog/android开发高手课/05.模块三架构演进/06"><span>39 | 移动开发新大陆： 边缘智能计算的趋势</span></a></li><li><a href="/blog/android开发高手课/05.模块三架构演进/07"><span>40 | 动态化实践，如何选择适合自己的方案？</span></a></li><li><a href="/blog/android开发高手课/05.模块三架构演进/08"><span>41 | 聊聊Flutter，面对层出不穷的新技术该如何跟进？</span></a></li><li><a href="/blog/android开发高手课/05.模块三架构演进/09"><span>42 | Android开发高手课学习心得</span></a></li></ul></li><li><a href="/blog/android开发高手课/06.练习sample跑起来">06.练习Sample跑起来</a><ul><li><a href="/blog/android开发高手课/06.练习sample跑起来/01"><span>练习Sample跑起来 | 热点问题答疑第1期</span></a></li><li><a href="/blog/android开发高手课/06.练习sample跑起来/02"><span>练习Sample跑起来 | 热点问题答疑第2期</span></a></li><li><a href="/blog/android开发高手课/06.练习sample跑起来/03"><span>练习Sample跑起来 | 热点问题答疑第3期</span></a></li><li><a href="/blog/android开发高手课/06.练习sample跑起来/04"><span>练习Sample跑起来 | 热点问题答疑第4期</span></a></li><li><a href="/blog/android开发高手课/06.练习sample跑起来/05"><span>练习Sample跑起来 | ASM插桩强化练习</span></a></li><li><a href="/blog/android开发高手课/06.练习sample跑起来/06"><span>练习Sample跑起来 | 唯鹿同学的练习手记 第1辑</span></a></li><li><a href="/blog/android开发高手课/06.练习sample跑起来/07"><span>练习Sample跑起来 | 唯鹿同学的练习手记 第2辑</span></a></li><li><a href="/blog/android开发高手课/06.练习sample跑起来/08"><span>练习Sample跑起来 | 唯鹿同学的练习手记 第3辑</span></a></li></ul></li><li><a href="/blog/android开发高手课/07.特别放送">07.特别放送</a><ul><li><a href="/blog/android开发高手课/07.特别放送/01"><span>Android JVM TI机制详解（内含福利彩蛋）</span></a></li><li><a href="/blog/android开发高手课/07.特别放送/02"><span>专栏学得苦？可能是方法没找对</span></a></li><li><a href="/blog/android开发高手课/07.特别放送/03"><span>专栏学得苦？可能你还需要一份配套学习书单</span></a></li><li><a href="/blog/android开发高手课/07.特别放送/04"><span>Native下如何获取调用栈？</span></a></li><li><a href="/blog/android开发高手课/07.特别放送/05"><span>聊聊Framework的学习方法</span></a></li><li><a href="/blog/android开发高手课/07.特别放送/06"><span>Android工程师的“面试指南”</span></a></li><li><a href="/blog/android开发高手课/07.特别放送/07"><span>程序员修炼之路 | 设计能力的提升途径</span></a></li></ul></li><li><a href="/blog/android开发高手课/08.结束语">08.结束语</a><ul><li><a href="/blog/android开发高手课/08.结束语/01"><span>结束语 | 移动开发的今天和明天</span></a></li><li><a href="/blog/android开发高手课/08.结束语/02"><span>结课测试 | 这些Android知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog/android开发高手课/summary">android开发高手课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="Native Hook的不同流派" data-depth="2"><a href="/blog/android开发高手课/05.模块三架构演进/02#native-hook的不同流派"><span>Native Hook的不同流派</span></a></li><li title="各个流派的优缺点比较" data-depth="2"><a href="/blog/android开发高手课/05.模块三架构演进/02#各个流派的优缺点比较"><span>各个流派的优缺点比较</span></a></li><li title="总结" data-depth="2"><a href="/blog/android开发高手课/05.模块三架构演进/02#总结"><span>总结</span></a></li><li title="课后作业" data-depth="2"><a href="/blog/android开发高手课/05.模块三架构演进/02#课后作业"><span>课后作业</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="35--native-hook-技术天使还是魔鬼"><a aria-hidden="true" tabindex="-1" href="/blog/android开发高手课/05.模块三架构演进/02#35--native-hook-技术天使还是魔鬼"><span class="icon icon-link"></span></a>35 | Native Hook 技术，天使还是魔鬼？</h1><p>相信一直坚持学习专栏的同学对Hook一定不会陌生，在前面很多期里我无数次提到Hook。可能有不少同学对于Hook还是“懵懵懂懂”，那今天我们从来头了解一下什么是Hook。</p><p>Hook直译过来就是“钩子”的意思，是指截获进程对某个API函数的调用，使得API的执行流程转向我们实现的代码片段，从而实现我们所需要得功能，这里的功能可以是监控、修复系统漏洞，也可以是劫持或者其他恶意行为。</p><p>相信许多新手第一次接触Hook时会觉得这项技术十分神秘，只能被少数高手、黑客所掌握，那Hook是不是真的难以掌握？希望今天的文章可以打消你的顾虑。</p><h2 id="native-hook的不同流派"><a aria-hidden="true" tabindex="-1" href="/blog/android开发高手课/05.模块三架构演进/02#native-hook的不同流派"><span class="icon icon-link"></span></a>Native Hook的不同流派</h2><p>对于Native Hook技术，我们比较熟悉的有GOT/PLT Hook、Trap Hook以及Inline Hook，下面我来逐个讲解这些Hook技术的实现原理和优劣比较。</p><p><strong>1. GOT/PLT Hook</strong></p><p>在<a target="_blank" rel="noopener noreferrer" href="https://github.com/AndroidAdvanceWithGeektime/Chapter06-plus">Chapter06-plus<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，我们使用了PLT Hook技术来获取线程创建的堆栈。先来回顾一下它的整个流程，我们将libart.so中的外部函数pthread_create替换成自己的方法pthread_create_hook。</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/05.%E6%A8%A1%E5%9D%97%E4%B8%89%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/resourceimage71f5715e03d40d7c5f185959e284c23e9df5.png" alt=""/></p><p>你可以发现，GOT/PLT Hook主要是用于替换某个SO的外部调用，通过将外部函数调用跳转成我们的目标函数。GOT/PLT Hook可以说是一个非常经典的Hook方法，它非常稳定，可以达到部署到生产环境的标准。</p><p>那GOT/PLT Hook的实现原理究竟是什么呢？你需要先对SO库文件的ELF文件格式和动态链接过程有所了解。</p><p><strong>ELF格式</strong></p><p>ELF（Executableand Linking Format）是可执行和链接格式，它是一个开放标准，各种UNIX系统的可执行文件大多采用ELF格式。虽然ELF文件本身就支持三种不同的类型（重定位、执行、共享），不同的视图下格式稍微不同，不过它有一个统一的结构，这个结构如下图所示。</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/05.%E6%A8%A1%E5%9D%97%E4%B8%89%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/resourceimage1896181d3fed100b9ca11360a03625db5296.png" alt=""/></p><p>网上介绍ELF格式的文章非常多，你可以参考<a target="_blank" rel="noopener noreferrer" href="https://felixzhang00.github.io/2016/12/24/2016-12-24-ELF%E6%96%87%E4%BB%B6%E8%A3%85%E8%BD%BD%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%8F%8Ahook%E5%8E%9F%E7%90%86/">《ELF文件格式解析》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。顾名思义，对于GOT/PLT Hook来说，我们主要关心“.plt”和“.got”这两个节区：</p><ul><li><p><strong>.plt</strong>。该节保存过程链接表（Procedure Linkage Table）。</p></li><li><p><strong>.got</strong>。该节保存着全局的偏移量表。</p></li></ul><p>我们也可以使用<code>readelf \-S</code>来查看ELF文件的具体信息。</p><p><strong>链接过程</strong></p><p>接下来我们再来看看动态链接的过程，当需要使用一个Native库（.so文件）的时候，我们需要调用<code>dlopen(&quot;libname.so&quot;)</code>来加载这个库。</p><p>在我们调用了<code>dlopen(&quot;libname.so&quot;)</code>之后，系统首先会检查缓存中已加载的ELF文件列表。如果未加载则执行加载过程，如果已加载则计数加一，忽略该调用。然后系统会用从libname.so的<code>dynamic</code>节区中读取其所依赖的库，按照相同的加载逻辑，把未在缓存中的库加入加载列表。</p><p>你可以使用下面这个命令来查看一个库的依赖：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">readelf -d &lt;library&gt; | grep NEEDED</span></div></pre></div><p>下面我们大概了解一下系统是如何加载的ELF文件的。</p><ul><li><p>读ELF的程序头部表，把所有PT_LOAD的节区mmap到内存中。</p></li><li><p>从“.dynamic”中读取各信息项，计算并保存所有节区的虚拟地址，然后执行重定位操作。</p></li><li><p>最后ELF加载成功，引用计数加一。</p></li></ul><p>但是这里有一个关键点，在ELF文件格式中我们只有函数的绝对地址。如果想在系统中运行，这里需要经过<strong>重定位</strong>。这其实是一个比较复杂的问题，因为不同机器的CPU架构、加载顺序不同，导致我们只能在运行时计算出这个值。不过还好动态加载器（/system/bin/linker）会帮助我们解决这个问题。</p><p>如果你理解了动态链接的过程，我们再回头来思考一下“.got”和“.plt”它们的具体含义。</p><ul><li><p><strong>The Global Offset Table (GOT)</strong>。简单来说就是在数据段的地址表，假定我们有一些代码段的指令引用一些地址变量，编译器会引用GOT表来替代直接引用绝对地址，因为绝对地址在编译期是无法知道的，只有重定位后才会得到 ，GOT自己本身将会包含函数引用的绝对地址。</p></li><li><p><strong>The Procedure Linkage Table (PLT)</strong>。PLT不同于GOT，它位于代码段，动态库的每一个外部函数都会在PLT中有一条记录，每一条PLT记录都是一小段可执行代码。 一般来说，外部代码都是在调用PLT表里的记录，然后PLT的相应记录会负责调用实际的函数。我们一般把这种设定叫作“<a target="_blank" rel="noopener noreferrer" href="http://en.wikipedia.org/wiki/Trampoline_(computing)">蹦床<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”（Trampoline）。</p></li></ul><p>PLT和GOT记录是一一对应的，并且GOT表第一次解析后会包含调用函数的实际地址。既然这样，那PLT的意义究竟是什么呢？PLT从某种意义上赋予我们一种懒加载的能力。当动态库首次被加载时，所有的函数地址并没有被解析。下面让我们结合图来具体分析一下首次函数调用，请注意图中黑色箭头为跳转，紫色为指针。</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/05.%E6%A8%A1%E5%9D%97%E4%B8%89%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/resourceimageb833b86ff32360acd5151050fd30e1762233.png" alt=""/></p><ul><li><p>我们在代码中调用func，编译器会把这个转化为func@plt，并在PLT表插入一条记录。</p></li><li><p>PLT表中第一条（或者说第0条）PLT[0]是一条特殊记录，它是用来帮助我们解析地址的。通常在类Linux系统，这个的实现会位于动态加载器，就是专栏前面文章提到的/system/bin/linker。</p></li><li><p>其余的PLT记录都均包含以下信息：</p><ul><li><p>跳转GOT表的指令（jmp *GOT[n]）。</p></li><li><p>为上面提到的第0条解析地址函数准备参数。</p></li><li><p>调用PLT[0]，这里resovler的实际地址是存储在GOT[2] 。</p></li></ul></li><li><p>在解析前GOT[n]会直接指向jmp *GOT[n]的下一条指令。在解析完成后，我们就得到了func的实际地址，动态加载器会将这个地址填入GOT[n]，然后调用func。</p></li></ul><p>如果对上面的这个调用流程还有疑问，你可以参考<a target="_blank" rel="noopener noreferrer" href="https://www.jianshu.com/p/0ac63c3744dd">《GOT表和PLT表》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>这篇文章，它里面有一张图非常清晰。</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/05.%E6%A8%A1%E5%9D%97%E4%B8%89%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/resourceimage8bc68bacb98e41eaa8ed048294dbf42896c6.png" alt=""/></p><p>当第一次调用发生后，之后再调用函数func就高效简单很多。首先调用PLT[n]，然后执行jmp *GOT[n]。GOT[n]直接指向func，这样就高效的完成了函数调用。</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/05.%E6%A8%A1%E5%9D%97%E4%B8%89%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/resourceimage081e08d7d70593533b9908426945d16ad91e.png" alt=""/></p><p>总结一下，因为很多函数可能在程序执行完时都不会被用到，比如错误处理函数或一些用户很少用到的功能模块等，那么一开始把所有函数都链接好实际就是一种浪费。为了提升动态链接的性能，我们可以使用PLT来实现延迟绑定的功能。</p><p>对于函数运行的实际地址，我们依然需要通过GOT表得到，整个简化过程如下：</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/05.%E6%A8%A1%E5%9D%97%E4%B8%89%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/resourceimage6927698af1afdf2327233ef5bf2d09df4c27.png" alt=""/></p><p>看到这里，相信你已经有了如何Hack这一过程的初步想法。这里业界通常会根据修改PLT记录或者GOT记录区分为GOT Hook和PLT Hook，但其本质原理十分接近。</p><p><strong>GOT/PLT Hook实践</strong></p><p>GOT/PLT Hook看似简单，但是实现起来也是有一些坑的，需要考虑兼容性的情况。一般来说，推荐使用业界的成熟方案。</p><ul><li><p>微信Matrix开源库的<a target="_blank" rel="noopener noreferrer" href="https://github.com/Tencent/matrix/tree/master/matrix/matrix-android/matrix-android-commons/src/main/cpp/elf_hook">ELF Hook<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它使用的是GOT Hook，主要使用它来做性能监控。</p></li><li><p>爱奇艺开源的的<a target="_blank" rel="noopener noreferrer" href="https://github.com/iqiyi/xHook">xHook<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它使用的也是GOT Hook。</p></li><li><p>Facebook的<a target="_blank" rel="noopener noreferrer" href="https://github.com/facebookincubator/profilo/tree/master/deps/plthooks">PLT Hook<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p></li></ul><p>如果不想深入它内部的原理，我们只需要直接使用这些开源的优秀方案就可以了。因为这种Hook方式非常成熟稳定，除了Hook线程的创建，我们还有很多其他的使用范例。</p><ul><li><p>“I/O优化”中使用<a target="_blank" rel="noopener noreferrer" href="https://github.com/Tencent/matrix/tree/master/matrix/matrix-android/matrix-io-canary">matrix-io-canary<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> Hook文件的操作。</p></li><li><p>“网络优化”中使用Hook了Socket的相关操作，具体你可以参考<a target="_blank" rel="noopener noreferrer" href="https://github.com/AndroidAdvanceWithGeektime/Chapter17">Chapter17<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p></li></ul><p>这种Hook方法也不是万能的，因为它只能替换导入函数的方式。有时候我们不一定可以找到这样的外部调用函数。如果想Hook函数的内部调用，这个时候就需要用到我们的Trap Hook或者Inline Hook了。</p><p><strong>2. Trap Hook</strong></p><p>对于函数内部的Hook，你可以先从头想一下，会发现调试器就具备一切Hook框架具有的能力，可以在目标函数前断住程序，修改内存、程序段，继续执行。相信很多同学都会使用调试器，但是对调试器如何工作却知之甚少。下面让我们先了解一下软件调试器是如何工作的。</p><p><strong>ptrace</strong></p><p>一般软件调试器都是通过ptrace系统调用和SIGTRAP配合来进行断点调试，首先我们来了解一下什么是ptrace，它又是如何断住程序运行，然后修改相关执行步骤的。</p><p>所谓合格的底层程序员，对于未知知识的了解，第一步就是使用<code>man</code>命令来查看系统文档。</p><blockquote><p>The ptrace() system call provides a means by which one process (the “tracer”) may observe and control the execution of another process (the “tracee”), and examine and change the tracee’s memory and registers. It is primarily used to implement breakpoint debugging and system call tracing.</p></blockquote><p>这段话直译过来就是，ptrace提供了一种让一个程序（tracer）观察或者控制另一个程序（tracee）执行流程，以及修改被控制程序内存和寄存器的方法，主要用于实现调试断点和系统调用跟踪。</p><p>我们再来简单了解一下调试器（GDB/LLDB）是如何使用ptrace的。首先调试器会基于要调试进程是否已启动，来决定是使用fork或者attach到目标进程。当调试器与目标程序绑定后，目标程序的任何signal（除SIGKILL）都会被调试器做先拦截，调试器会有机会对相关信号进行处理，然后再把执行权限交由目标程序继续执行。可以你已经想到了，这其实已经达到了Hook的目的。</p><p><strong>如何Hook</strong></p><p>但更进一步思考，如果我们不需要修改内存或者做类似调试器一样复杂的交互，我们完全可以不依赖ptrace，只需要接收相关signal即可。这时我们就想到了句柄（signal handler）。对！我们完全可以主动raise signal，然后使用signal handler来实现类似的Hook效果。</p><p>业界也有不少人将Trap Hook叫作断点Hook，它的原理就是在需要Hook的地方想办法触发断点，并捕获异常。一般我们会利用SIGTRAP或者SIGKILL（非法指令异常）这两种信号。下面以SIGTRAP信号为例，具体的实现步骤如下。</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/05.%E6%A8%A1%E5%9D%97%E4%B8%89%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/resourceimage07cc0746c1505e06c80345cbeb30b7c6c6cc.png" alt=""/></p><ul><li><p>注册信号接收句柄（signal handler），不同的体系结构可能会选取不同的信号，我们这里用SIGTRAP。</p></li><li><p>在我们需要Hook得部分插入Trap指令。</p></li><li><p>系统调用Trap指令，进入内核模式，调用我们已经在开始注册好的信号接收句柄（signal handler）。</p></li><li><p>执行我们信号接收句柄（signal handler），这里需要注意，所有在信号接收句柄（signal handler）执行的代码需要保证<a target="_blank" rel="noopener noreferrer" href="http://man7.org/linux/man-pages/man7/signal-safety.7.html">async-signal-safe<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。这里我们可以简单的只把信号接收句柄当作蹦床，使用logjmp跳出这个需要async-signal-safe（正如我在“崩溃分析”所说的，部分函数在signal回调中使用并不安全）的环境，然后再执行我们Hook的代码。</p></li><li><p>在执行完Hook的函数后，我们需要恢复现场。这里如果我们想继续调用原来的函数A，那直接回写函数A的原始指令并恢复寄存器状态。</p></li></ul><p><strong>Trap Hook实践</strong></p><p>Trap Hook兼容性非常好，它也可以在生产环境中大规模使用。但是它最大的问题是效率比较低，不适合Hook非常频繁调用的函数。</p><p>对于Trap Hook的实践方案，在“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/72642">卡顿优化（下）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”中，我提到过Facebook的<a target="_blank" rel="noopener noreferrer" href="https://github.com/facebookincubator/profilo">Profilo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它就是通过定期发送SIGPROF信号来实现卡顿监控的。</p><p><strong>3. Inline Hook</strong></p><p>跟Trap Hook一样，Inline Hook也是函数内部调用的Hook。它直接将函数开始（Prologue）处的指令更替为跳转指令，使得原函数直接跳转到Hook的目标函数函数，并保留原函数的调用接口以完成后续再调用回来的目的。</p><p>与GOT/PLT Hook相比，Inline Hook可以不受GOT/PLT表的限制，几乎可以Hook任何函数。不过其实现十分复杂，我至今没有见过可以用在生产环境的实现。并且在ARM体系结构下，无法对叶子函数和很短的函数进行Hook。</p><p>在深入“邪恶的”细节前，我们需要先对Inline Hook的大体流程有一个简单的了解。</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/05.%E6%A8%A1%E5%9D%97%E4%B8%89%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/resourceimageb756b78e7fd925a5299b13058ef54d094d56.jpg" alt=""/></p><p>如图所示，Inline Hook的基本思路就是在已有的代码段中插入跳转指令，把代码的执行流程转向我们实现的Hook函数中，然后再进行指令修复，并跳转回原函数继续执行。这段描述看起来是不是十分简单而且清晰？</p><p>对于Trap Hook，我们只需要在目标地址前插入特殊指令，并且在执行结束后把原始指令写回去就可以了。但是对Inline Hook来说，它是直接进行指令级的复写与修复。怎么理解呢？就相当于我们在运行过程中要去做ASM的字节码修改。</p><p>当然Inline Hook远远比ASM操作更加复杂，因为它还涉及不同CPU架构带来的指令集适配问题，我们需要根据不同指令集来分别进行指令复写与跳转。</p><p>下面我先来简单说明一下Android常见的CPU架构和指令集：</p><ul><li><p><strong>x86和MIPS架构</strong>。这两个架构已经基本没有多少用户了，我们可以直接忽视。一般来说我们只关心主流的ARM体系架构就可以了。</p></li><li><p><strong>ARMv5和ARMv7架构</strong>。它的指令集分为4字节对齐的定长的ARM指令集和2字节对齐的变长Thumb/Thumb-2指令集。Thumb-2指令集虽为2字节对齐，但指令集本身有16位也有32位。其中ARMv5使用的是16位的Thumb16，在ARMv7使用的是32位的Thumb32。<strong>不过目前ARMv5也基本没有多少用户了，我们也可以放弃Thumb16指令集的适配</strong>。</p></li><li><p><strong>ARMv8架构</strong>。64位的ARMv8架构可以兼容运行32位，所以它在ARM32和Thumb32指令集的基础上，增加了ARM64指令集。关于它们具体差异，你可以查看<a target="_blank" rel="noopener noreferrer" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0801b/IBAIEGDJ.html">ARM的官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p></li></ul><p>ARM64目前我还没有适配，不过Google Play要求所有应用在2019年8月1日之前需要支持64位，所以今年上半年也要折腾一下。但它们的原理基本类似，下面我以最主流的ARMv7架构为例，为你庖丁解牛Inline Hook。</p><p><strong>ARM32指令集</strong></p><p>ARMv7中有一种广为流传的<code>$PC=$PC+8</code>的说法。这是指ARMv7中的三级流水线（取指、解码、执行），换句话说<code>$PC</code>寄存器总是指向正在取指的指令，而不是指向正在执行的指令。取指总会比执行快2个指令，在ARM32指令集下2个指令的长度为8个字节，所以<code>$PC</code>寄存器的值总是比当前指令地址要大8。</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/05.%E6%A8%A1%E5%9D%97%E4%B8%89%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/resourceimagebbf9bb8ea924c24a27638d575e25ca101cf9.png" alt=""/></p><p>是不是感觉有些复杂，其实这是为了引出ARM指令集的常用跳转方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">LDR PC, [PC, #-4] ;0xE51FF004</span></div><div class="token-line"><span class="token plain">    $TRAMPOLIN_ADDR</span></div></pre></div><p>在了解了三级流水线以后，就不会对这个PC-4有什么疑惑了。</p><p>按照我们前面描述的Inline Hook的基本步骤，首先插入跳转指令，跳入我们的蹦床（Trampoline），执行我们实现的Hook后函数。这里还有一个“邪恶的”细节，由于指令执行是依赖当前运行环境的，即所有寄存器的值，而我们插入新的指令是有可能更改寄存器的状态的，所以我们要保存当前全部的寄存器状态到栈中，使用BLX指令跳转执行Hook后函数，执行完成后，再从栈中恢复所有的寄存器，最后才能像未Hook一样继续执行原先函数。</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/05.%E6%A8%A1%E5%9D%97%E4%B8%89%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/resourceimage052d0589d761c3079aad02287b13a7c0612d.jpg" alt=""/></p><p>在执行完Hook后的函数后，我们需要跳转回原先的函数继续执行。这里不要忘记我们在一开始覆盖的LDR指令，我们需要先执行被我们复写的指令，然后再使用如下指令，继续执行原先函数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">LDR PC, [PC, #-4]</span></div><div class="token-line"><span class="token plain">    HOOKED_ADDR+8</span></div></pre></div><p>是不是有一种大功告成的感觉？其实这里还有一个巨大的坑在等着我们，那就是<strong>指令修复</strong>。前面我提到保存并恢复了寄存器原有的状态，已达到可以继续像原有程序一样的继续执行。但仅仅是恢复寄存器就足够么？显然答案是否定的，虽然寄存器被我们完美恢复了，但是2条备份的指令被移动到了新的地址。当执行它们的时候，<code>$PC</code>寄存器的值是与原先不同的。这条指令的操作如果涉及<code>$PC</code>的值，那么它们将会执行出完全不同的结果。</p><p>到这里我就不对指令修复再深入解析了，感兴趣的同学可以在留言区进行讨论。</p><p><strong>Inline Hook实践</strong></p><p>对于Inline Hook，虽然它功能非常强大，而且执行效率也很高，但是业界目前还没有一套完全稳定可靠的开源方案。Inline Hook一般会使用在自动化测试或者线上疑难问题的定位，例如“UI优化”中说到libhwui.so崩溃问题的定位，我们就是利用Inline Hook去收集系统信息。</p><p>业界也有一些不错的参考方案：</p><ul><li><p><a target="_blank" rel="noopener noreferrer" href="http://www.cydiasubstrate.com/">Cydia Substrate<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。在<a target="_blank" rel="noopener noreferrer" href="https://github.com/AndroidAdvanceWithGeektime/Chapter03">Chapter3<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，我们就使用它来Hook系统的内存分配函数。</p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/crmulliner/adbi">adbi<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。支付宝在<a target="_blank" rel="noopener noreferrer" href="https://juejin.im/post/5be1077d518825171140dbfa">GC抑制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中使用的Hook框架，不过已经好几年没有更新了。</p></li></ul><h2 id="各个流派的优缺点比较"><a aria-hidden="true" tabindex="-1" href="/blog/android开发高手课/05.模块三架构演进/02#各个流派的优缺点比较"><span class="icon icon-link"></span></a>各个流派的优缺点比较</h2><p>最后我们再来总结一下不同的Hook方式的优缺点：</p><p>1.GOT/PLT Hook是一个比较中庸的方案，有较好的性能，中等的实现难度，但其只能Hook动态库之间的调用的函数，并且无法Hook未导出的私有函数，而且只存在安装与卸载2种状态，一旦安装就会Hook所有函数调用。</p><p>2.Trap Hook最为稳定，但由于需要切换运行模式（R0/R3），且依赖内核的信号机制，导致性能很差。</p><p>3.Inline Hook是一个非常激进的方案，有很好的性能，并且也没有PLT作用域的限制，可以说是一个非常灵活、完美的方案。但其实现难度极高，我至今也没有看到可以部署在生产环境的Inline Hook方案，因为涉及指令修复，需要编译器的各种优化。</p><p><img src="/images/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/05.%E6%A8%A1%E5%9D%97%E4%B8%89%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/resourceimagedbb9dbaf5281ac153571b5f2b93f75ae2db9.jpg" alt=""/></p><p>但是需要注意，无论是哪一种Hook都只能Hook到应用自身的进程，我们无法替换系统或其他应用进程的函数执行。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/android开发高手课/05.模块三架构演进/02#总结"><span class="icon icon-link"></span></a>总结</h2><p>总的来说Native Hook是一门非常底层的技术，它会涉及库文件编译、加载、链接等方方面面的知识，而且很多底层知识是与Android甚至移动平台无关的。</p><p>在这一领域，做安全的同学可能会更有发言权，我来讲可能班门弄斧了。不过希望通过这篇文章，让你对看似黑科技的Hook有一个大体的了解，希望可以在自己的平时的工作中使用Hook来完成一些看似不可能的任务，比如修复系统Bug、线上监控Native内存分配等。</p><h2 id="课后作业"><a aria-hidden="true" tabindex="-1" href="/blog/android开发高手课/05.模块三架构演进/02#课后作业"><span class="icon icon-link"></span></a>课后作业</h2><p>今天的信息量是不是有点大？关于Native Hook，你对它有什么看法，还有哪些疑问？欢迎留言跟我和其他同学一起讨论。</p><p>Native Hook技术的确非常复杂，即使我们不懂得它的内部原理，我们也应该学会使用成熟的开源框架去实现一些功能。当然对于想进一步深入研究的同学，推荐你学习下面这些资料。</p><ul><li><p><a target="_blank" rel="noopener noreferrer" href="https://docs.oracle.com/cd/E37934_01/pdf/E36754.pdf">链接程序和库指南<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://item.jd.com/10067200.html">程序员的自我修养：链接、装载与库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://item.jd.com/42971729145.html">链接器和加载器 Linkers and Loaders<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://item.jd.com/12240585.html">Linux二进制分析 Learning Linux Binary Analysis<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li></ul><p>如果你对调试器的研究也非常有兴趣，强烈推荐<a target="_blank" rel="noopener noreferrer" href="https://eli.thegreenplace.net/">Eli Bendersky<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>写的博客，里面有一系列非常优秀的底层知识文章。其中一些关于debugger的，感兴趣的同学可以去阅读，并亲手实现一个简单的调试器。</p><ul><li><p><a target="_blank" rel="noopener noreferrer" href="https://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1">how-debuggers-work-part-1<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints">how-debuggers-work-part-2-breakpoints<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information">how-debuggers-work-part-3-debugging-information<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li></ul><p>欢迎你点击“请朋友读”，把今天的内容分享给好友，邀请他一起学习。最后别忘了在评论区提交今天的作业，我也为认真完成作业的同学准备了丰厚的“学习加油礼包”，期待与你一起切磋进步哦。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/android开发高手课/05.模块三架构演进/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 14:46:55</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
