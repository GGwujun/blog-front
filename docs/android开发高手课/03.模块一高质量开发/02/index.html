<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-front/umi.css" />
    <script>
      window.routerBase = "/blog-front";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>02 | 崩溃优化（下）：应用崩溃了，你应该如何去分析？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/android开发高手课/03.模块一高质量开发/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-front/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>算法<ul><li><a href="/blog-front/业务开发算法50讲">业务开发算法50讲</a></li></ul></span><span>前端开发<ul><li><a href="/blog-front/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog-front/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog-front/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog-front/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog-front/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog-front/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog-front/重学前端">重学前端</a></li><li><a href="/blog-front/serverless入门课">serverless入门课</a></li><li><a href="/blog-front/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog-front/图解googlev8">图解googlev8</a></li><li><a href="/blog-front/vue3源码分析">vue3源码分析</a></li><li><a href="/blog-front/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog-front/webassembly入门">webassembly入门</a></li><li><a href="/blog-front/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog-front/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog-front/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog-front/搞定音频技术">搞定音频技术</a></li><li><a href="/blog-front/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog-front/logger">logger</a></li><li><a href="/blog-front/webpack">webpack</a></li><li><a href="/blog-front/webpackchain">webpackchain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog-front/react性能调优">react性能调优</a></li></ul></span><span>移动端开发<ul><li><a aria-current="page" class="active" href="/blog-front/android开发高手课">android开发高手课</a></li><li><a href="/blog-front/ios开发高手课">ios开发高手课</a></li></ul></span><span>产品与用户体验<ul><li><a href="/blog-front/视觉笔记入门课">视觉笔记入门课</a></li></ul></span><span>杂谈<ul><li><a href="/blog-front/git实战手册">git实战手册</a></li><li><a href="/blog-front/nodejs">nodejs</a></li><li><a href="/blog-front/reactjs">reactjs</a></li><li><a href="/blog-front/ui设计">ui设计</a></li><li><a href="/blog-front/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog-front/前端知识体系">前端知识体系</a></li><li><a href="/blog-front/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog-front/思考与成长">思考与成长</a></li><li><a href="/blog-front/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-front/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>算法<ul><li><a href="/blog-front/业务开发算法50讲">业务开发算法50讲</a></li></ul></li><li>前端开发<ul><li><a href="/blog-front/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog-front/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog-front/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog-front/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog-front/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog-front/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog-front/重学前端">重学前端</a></li><li><a href="/blog-front/serverless入门课">serverless入门课</a></li><li><a href="/blog-front/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog-front/图解googlev8">图解googlev8</a></li><li><a href="/blog-front/vue3源码分析">vue3源码分析</a></li><li><a href="/blog-front/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog-front/webassembly入门">webassembly入门</a></li><li><a href="/blog-front/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog-front/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog-front/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog-front/搞定音频技术">搞定音频技术</a></li><li><a href="/blog-front/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog-front/logger">logger</a></li><li><a href="/blog-front/webpack">webpack</a></li><li><a href="/blog-front/webpackchain">webpackchain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog-front/react性能调优">react性能调优</a></li></ul></li><li>移动端开发<ul><li><a aria-current="page" class="active" href="/blog-front/android开发高手课">android开发高手课</a></li><li><a href="/blog-front/ios开发高手课">ios开发高手课</a></li></ul></li><li>产品与用户体验<ul><li><a href="/blog-front/视觉笔记入门课">视觉笔记入门课</a></li></ul></li><li>杂谈<ul><li><a href="/blog-front/git实战手册">git实战手册</a></li><li><a href="/blog-front/nodejs">nodejs</a></li><li><a href="/blog-front/reactjs">reactjs</a></li><li><a href="/blog-front/ui设计">ui设计</a></li><li><a href="/blog-front/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog-front/前端知识体系">前端知识体系</a></li><li><a href="/blog-front/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog-front/思考与成长">思考与成长</a></li><li><a href="/blog-front/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-front/android开发高手课">android开发高手课</a></li><li><a href="/blog-front/android开发高手课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-front/android开发高手课/01.开篇词/01"><span>开篇词 | 焦虑的移动开发者该如何破局？</span></a></li></ul></li><li><a href="/blog-front/android开发高手课/02.导读">02.导读</a><ul><li><a href="/blog-front/android开发高手课/02.导读/01"><span>导读 | 如何打造高质量的应用？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-front/android开发高手课/03.模块一高质量开发">03.模块一高质量开发</a><ul><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/01"><span>01 | 崩溃优化（上）：关于“崩溃”那些事儿</span></a></li><li><a aria-current="page" class="active" href="/blog-front/android开发高手课/03.模块一高质量开发/02"><span>02 | 崩溃优化（下）：应用崩溃了，你应该如何去分析？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/03"><span>03 | 内存优化（上）：4GB内存时代，再谈内存优化</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/04"><span>04 | 内存优化（下）：内存优化这件事，应该从哪里着手？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/05"><span>05 | 卡顿优化（上）：你要掌握的卡顿分析方法</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/06"><span>06 | 卡顿优化（下）：如何监控应用卡顿？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/07"><span>06补充篇 | 卡顿优化：卡顿现场与卡顿分析</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/08"><span>07 | 启动优化（上）：从启动过程看启动速度优化</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/09"><span>08 | 启动优化（下）：优化启动速度的进阶方法</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/10"><span>09 | I/O优化（上）：开发工程师必备的I/O优化知识</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/11"><span>10 | I/O优化（中）：不同I/O方式的使用场景是什么？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/12"><span>11 | I/O优化（下）：如何监控线上I/O操作？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/13"><span>12 | 存储优化（上）：常见的数据存储方法有哪些？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/14"><span>13 | 存储优化（中）：如何优化数据存储？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/15"><span>14 | 存储优化（下）：数据库SQLite的使用和优化</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/16"><span>15 | 网络优化（上）：移动开发工程师必备的网络优化知识</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/17"><span>16 | 网络优化（中）：复杂多变的移动网络该如何优化？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/18"><span>17 | 网络优化（下）：大数据下网络该如何监控？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/19"><span>18 | 耗电优化（上）：从电量优化的演进看耗电分析</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/20"><span>19 | 耗电优化（下）：耗电的优化方法与线上监控</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/21"><span>20 | UI 优化（上）：UI 渲染的几个关键概念</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/22"><span>21 | UI 优化（下）：如何优化 UI 渲染？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/23"><span>22 | 包体积优化（上）：如何减少安装包大小？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/24"><span>23 | 包体积优化（下）：资源优化的进阶实践</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/25"><span>24 | 想成为Android高手，你需要先搞定这三个问题</span></a></li></ul></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发">04.模块二高效开发</a><ul><li><a href="/blog-front/android开发高手课/04.模块二高效开发/01"><span>25 | 如何提升组织与个人的研发效能？</span></a></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发/02"><span>26 | 关于编译，你需要了解什么？</span></a></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发/03"><span>27 | 编译插桩的三种方法：AspectJ、ASM、ReDex</span></a></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发/04"><span>28 | 大数据与AI，如何高效地测试？</span></a></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发/05"><span>29 | 从每月到每天，如何给版本发布提速？</span></a></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发/06"><span>30 | 数据评估（上）：如何实现高可用的上报组件？</span></a></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发/07"><span>31 | 数据评估（下）：什么是大数据平台？</span></a></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发/08"><span>32 | 线上疑难问题该如何排查和跟踪？</span></a></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发/09"><span>33 | 做一名有高度的移动开发工程师</span></a></li></ul></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进">05.模块三架构演进</a><ul><li><a href="/blog-front/android开发高手课/05.模块三架构演进/01"><span>34 | 聊聊重构：优秀的架构都是演进而来的</span></a></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进/02"><span>35 | Native Hook 技术，天使还是魔鬼？</span></a></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进/03"><span>36 | 跨平台开发的现状与应用</span></a></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进/04"><span>37 | 移动开发新大陆：工作三年半，移动开发转型手游开发</span></a></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进/05"><span>38 | 移动开发新大陆：Android音视频开发</span></a></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进/06"><span>39 | 移动开发新大陆： 边缘智能计算的趋势</span></a></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进/07"><span>40 | 动态化实践，如何选择适合自己的方案？</span></a></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进/08"><span>41 | 聊聊Flutter，面对层出不穷的新技术该如何跟进？</span></a></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进/09"><span>42 | Android开发高手课学习心得</span></a></li></ul></li><li><a href="/blog-front/android开发高手课/06.练习sample跑起来">06.练习Sample跑起来</a><ul><li><a href="/blog-front/android开发高手课/06.练习sample跑起来/01"><span>练习Sample跑起来 | 热点问题答疑第1期</span></a></li><li><a href="/blog-front/android开发高手课/06.练习sample跑起来/02"><span>练习Sample跑起来 | 热点问题答疑第2期</span></a></li><li><a href="/blog-front/android开发高手课/06.练习sample跑起来/03"><span>练习Sample跑起来 | 热点问题答疑第3期</span></a></li><li><a href="/blog-front/android开发高手课/06.练习sample跑起来/04"><span>练习Sample跑起来 | 热点问题答疑第4期</span></a></li><li><a href="/blog-front/android开发高手课/06.练习sample跑起来/05"><span>练习Sample跑起来 | ASM插桩强化练习</span></a></li><li><a href="/blog-front/android开发高手课/06.练习sample跑起来/06"><span>练习Sample跑起来 | 唯鹿同学的练习手记 第1辑</span></a></li><li><a href="/blog-front/android开发高手课/06.练习sample跑起来/07"><span>练习Sample跑起来 | 唯鹿同学的练习手记 第2辑</span></a></li><li><a href="/blog-front/android开发高手课/06.练习sample跑起来/08"><span>练习Sample跑起来 | 唯鹿同学的练习手记 第3辑</span></a></li></ul></li><li><a href="/blog-front/android开发高手课/07.特别放送">07.特别放送</a><ul><li><a href="/blog-front/android开发高手课/07.特别放送/01"><span>Android JVM TI机制详解（内含福利彩蛋）</span></a></li><li><a href="/blog-front/android开发高手课/07.特别放送/02"><span>专栏学得苦？可能是方法没找对</span></a></li><li><a href="/blog-front/android开发高手课/07.特别放送/03"><span>专栏学得苦？可能你还需要一份配套学习书单</span></a></li><li><a href="/blog-front/android开发高手课/07.特别放送/04"><span>Native下如何获取调用栈？</span></a></li><li><a href="/blog-front/android开发高手课/07.特别放送/05"><span>聊聊Framework的学习方法</span></a></li><li><a href="/blog-front/android开发高手课/07.特别放送/06"><span>Android工程师的“面试指南”</span></a></li><li><a href="/blog-front/android开发高手课/07.特别放送/07"><span>程序员修炼之路 | 设计能力的提升途径</span></a></li></ul></li><li><a href="/blog-front/android开发高手课/08.结束语">08.结束语</a><ul><li><a href="/blog-front/android开发高手课/08.结束语/01"><span>结束语 | 移动开发的今天和明天</span></a></li><li><a href="/blog-front/android开发高手课/08.结束语/02"><span>结课测试 | 这些Android知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-front/android开发高手课/summary">android开发高手课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="崩溃现场" data-depth="2"><a href="/blog-front/android开发高手课/03.模块一高质量开发/02#崩溃现场"><span>崩溃现场</span></a></li><li title="崩溃分析" data-depth="2"><a href="/blog-front/android开发高手课/03.模块一高质量开发/02#崩溃分析"><span>崩溃分析</span></a></li><li title="总结" data-depth="2"><a href="/blog-front/android开发高手课/03.模块一高质量开发/02#总结"><span>总结</span></a></li><li title="课后作业" data-depth="2"><a href="/blog-front/android开发高手课/03.模块一高质量开发/02#课后作业"><span>课后作业</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="02--崩溃优化下应用崩溃了你应该如何去分析"><a aria-hidden="true" tabindex="-1" href="/blog-front/android开发高手课/03.模块一高质量开发/02#02--崩溃优化下应用崩溃了你应该如何去分析"><span class="icon icon-link"></span></a>02 | 崩溃优化（下）：应用崩溃了，你应该如何去分析？</h1><p>在侦探漫画《名侦探柯南》中，无论柯南走到哪里都会遇到新的“案件”，这也很像程序员的“日常”，我们每天工作也会遇到各种各样的疑难问题，“崩溃”就是其中比较常见的一种问题。</p><p>解决崩溃跟破案一样需要经验，我们分析的问题越多越熟练，定位问题就会越快越准。当然这里也有很多套路，比如对于“案发现场”我们应该留意哪些信息？怎样找到更多的“证人”和“线索”？“侦查案件”的一般流程是什么？对不同类型的“案件”分别应该使用什么样的调查方式？</p><p>“真相永远只有一个”，崩溃也并不可怕。通过今天的学习，希望你能成为代码届的名侦探柯南。</p><h2 id="崩溃现场"><a aria-hidden="true" tabindex="-1" href="/blog-front/android开发高手课/03.模块一高质量开发/02#崩溃现场"><span class="icon icon-link"></span></a>崩溃现场</h2><p>崩溃现场是我们的“第一案发现场”，它保留着很多有价值的线索。在这里我们挖掘到的信息越多，下一步分析的方向就越清晰，而不是去靠盲目猜测。</p><p>操作系统是整个崩溃过程的“旁观者”，也是我们最重要的“证人”。一个好的崩溃捕获工具知道应该采集哪些系统信息，也知道在什么场景要深入挖掘哪些内容，从而可以更好地帮助我们解决问题。</p><p>接下来我们具体来看看在崩溃现场应该采集哪些信息。</p><p>1.崩溃信息</p><p>从崩溃的基本信息，我们可以对崩溃有初步的判断。</p><ul><li><p>进程名、线程名。崩溃的进程是前台进程还是后台进程，崩溃是不是发生在UI线程。</p></li><li><p>崩溃堆栈和类型。崩溃是属于Java崩溃、Native崩溃，还是ANR，对于不同类型的崩溃我们关注的点也不太一样。特别需要看崩溃堆栈的栈顶，看具体崩溃在系统的代码，还是我们自己的代码里面。</p></li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Process Name: &#x27;com.sample.crash&#x27;</span></div><div class="token-line"><span class="token plain">    Thread Name: &#x27;MyThread&#x27;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    java.lang.NullPointerException</span></div><div class="token-line"><span class="token plain">        at ...TestsActivity.crashInJava(TestsActivity.java:275)</span></div></pre></div><p>有时候我们除了崩溃的线程，还希望拿到其他关键的线程的日志。就像上面的例子，虽然是MyThread线程崩溃，但是我也希望可以知道主线程当前的调用栈。</p><p>2.系统信息</p><p>系统的信息有时候会带有一些关键的线索，对我们解决问题有非常大的帮助。</p><ul><li>Logcat。这里包括应用、系统的运行日志。由于系统权限问题，获取到的Logcat可能只包含与当前App相关的。其中系统的event logcat会记录App运行的一些基本情况，记录在文件/system/etc/event-log-tags中。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">system logcat:</span></div><div class="token-line"><span class="token plain">    10-25 17:13:47.788 21430 21430 D dalvikvm: Trying to load lib ... </span></div><div class="token-line"><span class="token plain">    event logcat:</span></div><div class="token-line"><span class="token plain">    10-25 17:13:47.788 21430 21430 I am_on_resume_called: 生命周期</span></div><div class="token-line"><span class="token plain">    10-25 17:13:47.788 21430 21430 I am_low_memory: 系统内存不足</span></div><div class="token-line"><span class="token plain">    10-25 17:13:47.788 21430 21430 I am_destroy_activity: 销毁 Activty</span></div><div class="token-line"><span class="token plain">    10-25 17:13:47.888 21430 21430 I am_anr: ANR 以及原因</span></div><div class="token-line"><span class="token plain">    10-25 17:13:47.888 21430 21430 I am_kill: APP 被杀以及原因</span></div></pre></div><ul><li><p>机型、系统、厂商、CPU、ABI、Linux版本等。我们会采集多达几十个维度，这对后面讲到寻找共性问题会很有帮助。</p></li><li><p>设备状态：是否root、是否是模拟器。一些问题是由Xposed或多开软件造成，对这部分问题我们要区别对待。</p></li></ul><p>3.内存信息</p><p>OOM、ANR、虚拟内存耗尽等，很多崩溃都跟内存有直接关系。如果我们把用户的手机内存分为“2GB以下”和“2GB以上”两个桶，会发现“2GB以下”用户的崩溃率是“2GB以上”用户的几倍。</p><ul><li><p>系统剩余内存。关于系统内存状态，可以直接读取文件/proc/meminfo。当系统可用内存很小（低于MemTotal的 10%）时，OOM、大量GC、系统频繁自杀拉起等问题都非常容易出现。</p></li><li><p>应用使用内存。包括Java内存、RSS（Resident Set Size）、PSS（Proportional Set Size），我们可以得出应用本身内存的占用大小和分布。PSS和RSS通过/proc/self/smap计算，可以进一步得到例如apk、dex、so等更加详细的分类统计。</p><ul><li>虚拟内存。虚拟内存可以通过/proc/self/status得到，通过/proc/self/maps文件可以得到具体的分布情况。有时候我们一般不太重视虚拟内存，但是很多类似OOM、tgkill等问题都是虚拟内存不足导致的。</li></ul></li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Name:     com.sample.name   // 进程名</span></div><div class="token-line"><span class="token plain">    FDSize:   800               // 当前进程申请的文件句柄个数</span></div><div class="token-line"><span class="token plain">    VmPeak:   3004628 kB        // 当前进程的虚拟内存峰值大小</span></div><div class="token-line"><span class="token plain">    VmSize:   2997032 kB        // 当前进程的虚拟内存大小</span></div><div class="token-line"><span class="token plain">    Threads:  600               // 当前进程包含的线程个数</span></div></pre></div><p>一般来说，对于32位进程，如果是32位的CPU，虚拟内存达到3GB就可能会引起内存申请失败的问题。如果是64位的CPU，虚拟内存一般在3～4GB之间。当然如果我们支持64位进程，虚拟内存就不会成为问题。Google Play要求 2019年8月一定要支持64位，在国内虽然支持64位的设备已经在90%以上了，但是商店都不支持区分CPU架构类型发布，普及起来需要更长的时间。</p><p>4.资源信息</p><p>有的时候我们会发现应用堆内存和设备内存都非常充足，还是会出现内存分配失败的情况，这跟资源泄漏可能有比较大的关系。</p><ul><li>文件句柄fd。文件句柄的限制可以通过/proc/self/limits获得，一般单个进程允许打开的最大文件句柄个数为1024。但是如果文件句柄超过800个就比较危险，需要将所有的fd以及对应的文件名输出到日志中，进一步排查是否出现了有文件或者线程的泄漏。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">opened files count 812:</span></div><div class="token-line"><span class="token plain">    0 -&gt; /dev/null</span></div><div class="token-line"><span class="token plain">    1 -&gt; /dev/log/main4 </span></div><div class="token-line"><span class="token plain">    2 -&gt; /dev/binder</span></div><div class="token-line"><span class="token plain">    3 -&gt; /data/data/com.crash.sample/files/test.config</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><ul><li>线程数。当前线程数大小可以通过上面的status文件得到，一个线程可能就占2MB的虚拟内存，过多的线程会对虚拟内存和文件句柄带来压力。根据我的经验来说，如果线程数超过400个就比较危险。需要将所有的线程id以及对应的线程名输出到日志中，进一步排查是否出现了线程相关的问题。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">threads count 412:               </span></div><div class="token-line"><span class="token plain">     1820 com.sample.crashsdk                         </span></div><div class="token-line"><span class="token plain">     1844 ReferenceQueueD                                             </span></div><div class="token-line"><span class="token plain">     1869 FinalizerDaemon   </span></div><div class="token-line"><span class="token plain">     ...</span></div></pre></div><ul><li>JNI。使用JNI时，如果不注意很容易出现引用失效、引用爆表等一些崩溃。我们可以通过DumpReferenceTables统计JNI的引用表，进一步分析是否出现了JNI泄漏等问题。</li></ul><p>5.应用信息</p><p>除了系统，其实我们的应用更懂自己，可以留下很多相关的信息。</p><ul><li><p>崩溃场景。崩溃发生在哪个Activity或Fragment，发生在哪个业务中。</p></li><li><p>关键操作路径。不同于开发过程详细的打点日志，我们可以记录关键的用户操作路径，这对我们复现崩溃会有比较大的帮助。</p></li><li><p>其他自定义信息。不同的应用关心的重点可能不太一样，比如网易云音乐会关注当前播放的音乐，QQ浏览器会关注当前打开的网址或视频。此外例如运行时间、是否加载了补丁、是否是全新安装或升级等信息也非常重要。</p></li></ul><p>除了上面这些通用的信息外，针对特定的一些崩溃，我们可能还需要获取类似磁盘空间、电量、网络使用等特定信息。所以说一个好的崩溃捕获工具，会根据场景为我们采集足够多的信息，让我们有更多的线索去分析和定位问题。当然数据的采集需要注意用户隐私，做到足够强度的加密和脱敏。</p><h2 id="崩溃分析"><a aria-hidden="true" tabindex="-1" href="/blog-front/android开发高手课/03.模块一高质量开发/02#崩溃分析"><span class="icon icon-link"></span></a>崩溃分析</h2><p>有了这么多现场信息之后，我们可以开始真正的“破案”之旅了。绝大部分的“案件”只要我们肯花功夫，最后都能真相大白。不要畏惧问题，经过耐心和细心地分析，总能敏锐地发现一些异常或关键点，并且还要敢于怀疑和验证。下面我重点给你介绍崩溃分析“三部曲”。</p><p>第一步：确定重点</p><p>确认和分析重点，关键在于在日志中找到重要的信息，对问题有一个大致判断。一般来说，我建议在确定重点这一步可以关注以下几点。</p><p><strong>1. 确认严重程度</strong>。解决崩溃也要看性价比，我们优先解决Top崩溃或者对业务有重大影响，例如启动、支付过程的崩溃。我曾经有一次辛苦了几天解决了一个大的崩溃，但下个版本产品就把整个功能都删除了，这令我很崩溃。</p><p><strong>2. 崩溃基本信息</strong>。确定崩溃的类型以及异常描述，对崩溃有大致的判断。一般来说，大部分的简单崩溃经过这一步已经可以得到结论。</p><ul><li><p>Java崩溃。Java崩溃类型比较明显，比如NullPointerException是空指针，OutOfMemoryError是资源不足，这个时候需要去进一步查看日志中的 “内存信息”和“资源信息”。</p></li><li><p>Native崩溃。需要观察signal、code、fault addr等内容，以及崩溃时Java的堆栈。关于各signal含义的介绍，你可以查看<a target="_blank" rel="noopener noreferrer" href="http://www.mkssoftware.com/docs/man5/siginfo_t.5.asp">崩溃信号介绍<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。比较常见的是有SIGSEGV和SIGABRT，前者一般是由于空指针、非法指针造成，后者主要因为ANR和调用abort() 退出所导致。</p></li><li><p><strong>ANR</strong>。我的经验是，先看看主线程的堆栈，是否是因为锁等待导致。接着看看ANR日志中iowait、CPU、GC、system server等信息，进一步确定是I/O问题，或是CPU竞争问题，还是由于大量GC导致卡死。</p></li></ul><p><strong>3. Logcat</strong>。Logcat一般会存在一些有价值的线索，日志级别是Warning、Error的需要特别注意。从Logcat中我们可以看到当时系统的一些行为跟手机的状态，例如出现ANR时，会有“am_anr”；App被杀时，会有“am_kill”。不同的系统、厂商输出的日志有所差别，<strong>当从一条崩溃日志中无法看出问题的原因，或者得不到有用信息时，不要放弃，建议查看相同崩溃点下的更多崩溃日志。</strong></p><p><strong>4. 各个资源情况</strong>。结合崩溃的基本信息，我们接着看看是不是跟 “内存信息” 有关，是不是跟“资源信息”有关。比如是物理内存不足、虚拟内存不足，还是文件句柄fd泄漏了。</p><p>无论是资源文件还是Logcat，内存与线程相关的信息都需要特别注意，很多崩溃都是由于它们使用不当造成的。</p><p>第二步：查找共性</p><p>如果使用了上面的方法还是不能有效定位问题，我们可以尝试查找这类崩溃有没有什么共性。找到了共性，也就可以进一步找到差异，离解决问题也就更进一步。</p><p>机型、系统、ROM、厂商、ABI，这些采集到的系统信息都可以作为维度聚合，共性问题例如是不是因为安装了Xposed，是不是只出现在x86的手机，是不是只有三星这款机型，是不是只在Android 5.0的系统上。应用信息也可以作为维度来聚合，比如正在打开的链接、正在播放的视频、国家、地区等。</p><p>找到了共性，可以对你下一步复现问题有更明确的指引。</p><p>第三步：尝试复现</p><p>如果我们已经大概知道了崩溃的原因，为了进一步确认更多信息，就需要尝试复现崩溃。如果我们对崩溃完全没有头绪，也希望通过用户操作路径来尝试重现，然后再去分析崩溃原因。</p><p>“只要能本地复现，我就能解”，相信这是很多开发跟测试说过的话。有这样的底气主要是因为在稳定的复现路径上面，我们可以采用增加日志或使用Debugger、GDB等各种各样的手段或工具做进一步分析。</p><p>回想当时在开发Tinker的时候，我们遇到了各种各样的奇葩问题。比如某个厂商改了底层实现、新的Android系统实现有所更改，都需要去Google、翻源码，有时候还需要去抠厂商的ROM或手动刷ROM。这个痛苦的经历告诉我，很多疑难问题需要我们耐得住寂寞，反复猜测、反复发灰度、反复验证。</p><p>疑难问题：系统崩溃</p><p>系统崩溃常常令我们感到非常无助，它可能是某个Android版本的bug，也可能是某个厂商修改ROM导致。这种情况下的崩溃堆栈可能完全没有我们自己的代码，很难直接定位问题。针对这种疑难问题，我来谈谈我的解决思路。</p><p><strong>1. 查找可能的原因</strong>。通过上面的共性归类，我们先看看是某个系统版本的问题，还是某个厂商特定ROM的问题。虽然崩溃日志可能没有我们自己的代码，但通过操作路径和日志，我们可以找到一些怀疑的点。</p><p><strong>2. 尝试规避</strong>。查看可疑的代码调用，是否使用了不恰当的API，是否可以更换其他的实现方式规避。</p><p><strong>3. Hook解决</strong>。这里分为Java Hook和Native Hook。以我最近解决的一个系统崩溃为例，我们发现线上出现一个Toast相关的系统崩溃，它只出现在Android 7.0的系统中，看起来是在Toast显示的时候窗口的token已经无效了。这有可能出现在Toast需要显示时，窗口已经销毁了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">android.view.WindowManager$BadTokenException: </span></div><div class="token-line"><span class="token plain">    	at android.view.ViewRootImpl.setView(ViewRootImpl.java)</span></div><div class="token-line"><span class="token plain">    	at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java)</span></div><div class="token-line"><span class="token plain">    	at android.view.WindowManagerImpl.addView(WindowManagerImpl.java4)</span></div><div class="token-line"><span class="token plain">    	at android.widget.Toast$TN.handleShow(Toast.java)</span></div></pre></div><p>为什么Android 8.0的系统不会有这个问题？在查看Android 8.0的源码后我们发现有以下修改：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">try {</span></div><div class="token-line"><span class="token plain">      mWM.addView(mView, mParams);</span></div><div class="token-line"><span class="token plain">      trySendAccessibilityEvent();</span></div><div class="token-line"><span class="token plain">    } catch (WindowManager.BadTokenException e) {</span></div><div class="token-line"><span class="token plain">      /* ignore */</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>考虑再三，我们决定参考Android 8.0的做法，直接catch住这个异常。这里的关键在于寻找Hook点，这个案例算是相对比较简单的。Toast里面有一个变量叫mTN，它的类型为handler，我们只需要代理它就可以实现捕获。</p><p>如果你做到了我上面说的这些，<strong>95%以上的崩溃都能解决或者规避，大部分的系统崩溃也是如此</strong>。当然总有一些疑难问题需要依赖到用户的真实环境，我们希望具备类似动态跟踪和调试的能力。专栏后面还会讲到xlog日志、远程诊断、动态分析等高级手段，可以帮助我们进一步调试线上疑难问题，敬请期待。</p><p>崩溃攻防是一个长期的过程，我们希望尽可能地提前预防崩溃的发生，将它消灭在萌芽阶段。这可能涉及我们应用的整个流程，包括人员的培训、编译检查、静态扫描工作，还有规范的测试、灰度、发布流程等。</p><p>而崩溃优化也不是孤立的，它跟我们后面讲到的内存、卡顿、I/O等内容都有关。可能等你学完整个课程后，再回头来看会有不同的理解。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-front/android开发高手课/03.模块一高质量开发/02#总结"><span class="icon icon-link"></span></a>总结</h2><p>今天我们介绍了崩溃问题的一些分析方法、特殊技巧、以及疑难和常见问题的解决方法。当然崩溃分析要具体问题具体分析，不同类型的应用侧重点可能也有所不同，我们不能只局限在上面所说的一些方法。</p><p>讲讲自己的一些心得体会，在解决崩溃特别是一些疑难问题时，总会觉得患得患失。有时候解了一个问题，发现其他问题也跟“开心消消乐”一样消失了。有时候有些问题“解不出来郁闷，解出来更郁闷”，可能只是一个小的代码疏忽，换来了一个月的青春和很多根白头发。</p><h2 id="课后作业"><a aria-hidden="true" tabindex="-1" href="/blog-front/android开发高手课/03.模块一高质量开发/02#课后作业"><span class="icon icon-link"></span></a>课后作业</h2><p>在崩溃的长期保卫战中，你肯定有一些经典的漂亮战役，希望可以拿出来跟其他同学分享。当然也会有一些百思不得其解的问题，今天的课后作业是分享你破解崩溃问题的思路和方法，总结一下通过Sample的练习有什么收获。</p><p>如果想向崩溃发起挑战，那么Top 20崩溃就是我们无法避免的对手。在这里面会有不少疑难的系统崩溃问题，TimeoutException就是其中比较经典的一个。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">java.util.concurrent.TimeoutException: </span></div><div class="token-line"><span class="token plain">             android.os.BinderProxy.finalize() timed out after 10 seconds</span></div><div class="token-line"><span class="token plain">    at android.os.BinderProxy.destroy(Native Method)</span></div><div class="token-line"><span class="token plain">    at android.os.BinderProxy.finalize(Binder.java:459)</span></div></pre></div><p>今天的<a target="_blank" rel="noopener noreferrer" href="http://github.com/AndroidAdvanceWithGeektime/Chapter02">Sample<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>提供了一种“完全解决”TimeoutException的方法，主要是希望你可以更好地学习解决系统崩溃的套路。</p><p>1.通过源码分析。我们发现TimeoutException是由系统的FinalizerWatchdogDaemon抛出来的。</p><p>2.寻找可以规避的方法。尝试调用了它的Stop()方法，但是线上发现在Android 6.0之前会有线程同步问题。</p><p>3.寻找其他可以Hook的点。通过代码的依赖关系，发现一个取巧的Hook点。</p><p>最终代码你可以参考Sample的实现，但是建议只在灰度中使用。这里需要提的是，虽然有一些黑科技可以帮助我们解决某些问题，但对于黑科技的使用我们需要慎重，比如有的黑科技对保活进程频率没有做限制，可能会导致系统卡死。</p><p>欢迎你点击“请朋友读”，把今天的内容分享给好友，邀请他一起学习。最后别忘了在评论区提交今天的作业，我也为认真完成作业的同学准备了丰厚的“<a target="_blank" rel="noopener noreferrer" href="http://time.geekbang.org/column/article/70250">学习加油礼包<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”，期待与你一起切磋进步哦。</p><p><img src="/blog-front/static/httpsstatic001geekbangorgresourceimage24c024c190870d71c3daa203a939d67358c0.582239a0.jpg" alt=""/><img src="/blog-front/static/httpsstatic001geekbangorgresourceimage30aa306ef8892cc985a19fdd36534e7c5daa.6821b3bb.png" alt=""/></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/android开发高手课/03.模块一高质量开发/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 20:45:59</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-front/umi.js"></script>
  </body>
</html>
