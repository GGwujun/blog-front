<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-front/umi.css" />
    <script>
      window.routerBase = "/blog-front";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>14 | 存储优化（下）：数据库SQLite的使用和优化 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/android开发高手课/03.模块一高质量开发/15" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-front/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>算法<ul><li><a href="/blog-front/业务开发算法50讲">业务开发算法50讲</a></li></ul></span><span>前端开发<ul><li><a href="/blog-front/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog-front/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog-front/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog-front/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog-front/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog-front/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog-front/重学前端">重学前端</a></li><li><a href="/blog-front/serverless入门课">serverless入门课</a></li><li><a href="/blog-front/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog-front/图解googlev8">图解googlev8</a></li><li><a href="/blog-front/vue3源码分析">vue3源码分析</a></li><li><a href="/blog-front/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog-front/webassembly入门">webassembly入门</a></li><li><a href="/blog-front/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog-front/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog-front/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog-front/搞定音频技术">搞定音频技术</a></li><li><a href="/blog-front/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog-front/logger">logger</a></li><li><a href="/blog-front/webpack">webpack</a></li><li><a href="/blog-front/webpackchain">webpackchain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog-front/react性能调优">react性能调优</a></li></ul></span><span>移动端开发<ul><li><a aria-current="page" class="active" href="/blog-front/android开发高手课">android开发高手课</a></li><li><a href="/blog-front/ios开发高手课">ios开发高手课</a></li></ul></span><span>产品与用户体验<ul><li><a href="/blog-front/视觉笔记入门课">视觉笔记入门课</a></li></ul></span><span>杂谈<ul><li><a href="/blog-front/git实战手册">git实战手册</a></li><li><a href="/blog-front/nodejs">nodejs</a></li><li><a href="/blog-front/reactjs">reactjs</a></li><li><a href="/blog-front/ui设计">ui设计</a></li><li><a href="/blog-front/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog-front/前端知识体系">前端知识体系</a></li><li><a href="/blog-front/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog-front/思考与成长">思考与成长</a></li><li><a href="/blog-front/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-front/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>算法<ul><li><a href="/blog-front/业务开发算法50讲">业务开发算法50讲</a></li></ul></li><li>前端开发<ul><li><a href="/blog-front/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog-front/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog-front/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog-front/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog-front/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog-front/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog-front/重学前端">重学前端</a></li><li><a href="/blog-front/serverless入门课">serverless入门课</a></li><li><a href="/blog-front/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog-front/图解googlev8">图解googlev8</a></li><li><a href="/blog-front/vue3源码分析">vue3源码分析</a></li><li><a href="/blog-front/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog-front/webassembly入门">webassembly入门</a></li><li><a href="/blog-front/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog-front/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog-front/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog-front/搞定音频技术">搞定音频技术</a></li><li><a href="/blog-front/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog-front/logger">logger</a></li><li><a href="/blog-front/webpack">webpack</a></li><li><a href="/blog-front/webpackchain">webpackchain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog-front/react性能调优">react性能调优</a></li></ul></li><li>移动端开发<ul><li><a aria-current="page" class="active" href="/blog-front/android开发高手课">android开发高手课</a></li><li><a href="/blog-front/ios开发高手课">ios开发高手课</a></li></ul></li><li>产品与用户体验<ul><li><a href="/blog-front/视觉笔记入门课">视觉笔记入门课</a></li></ul></li><li>杂谈<ul><li><a href="/blog-front/git实战手册">git实战手册</a></li><li><a href="/blog-front/nodejs">nodejs</a></li><li><a href="/blog-front/reactjs">reactjs</a></li><li><a href="/blog-front/ui设计">ui设计</a></li><li><a href="/blog-front/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog-front/前端知识体系">前端知识体系</a></li><li><a href="/blog-front/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog-front/思考与成长">思考与成长</a></li><li><a href="/blog-front/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-front/android开发高手课">android开发高手课</a></li><li><a href="/blog-front/android开发高手课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-front/android开发高手课/01.开篇词/01"><span>开篇词 | 焦虑的移动开发者该如何破局？</span></a></li></ul></li><li><a href="/blog-front/android开发高手课/02.导读">02.导读</a><ul><li><a href="/blog-front/android开发高手课/02.导读/01"><span>导读 | 如何打造高质量的应用？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-front/android开发高手课/03.模块一高质量开发">03.模块一高质量开发</a><ul><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/01"><span>01 | 崩溃优化（上）：关于“崩溃”那些事儿</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/02"><span>02 | 崩溃优化（下）：应用崩溃了，你应该如何去分析？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/03"><span>03 | 内存优化（上）：4GB内存时代，再谈内存优化</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/04"><span>04 | 内存优化（下）：内存优化这件事，应该从哪里着手？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/05"><span>05 | 卡顿优化（上）：你要掌握的卡顿分析方法</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/06"><span>06 | 卡顿优化（下）：如何监控应用卡顿？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/07"><span>06补充篇 | 卡顿优化：卡顿现场与卡顿分析</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/08"><span>07 | 启动优化（上）：从启动过程看启动速度优化</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/09"><span>08 | 启动优化（下）：优化启动速度的进阶方法</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/10"><span>09 | I/O优化（上）：开发工程师必备的I/O优化知识</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/11"><span>10 | I/O优化（中）：不同I/O方式的使用场景是什么？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/12"><span>11 | I/O优化（下）：如何监控线上I/O操作？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/13"><span>12 | 存储优化（上）：常见的数据存储方法有哪些？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/14"><span>13 | 存储优化（中）：如何优化数据存储？</span></a></li><li><a aria-current="page" class="active" href="/blog-front/android开发高手课/03.模块一高质量开发/15"><span>14 | 存储优化（下）：数据库SQLite的使用和优化</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/16"><span>15 | 网络优化（上）：移动开发工程师必备的网络优化知识</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/17"><span>16 | 网络优化（中）：复杂多变的移动网络该如何优化？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/18"><span>17 | 网络优化（下）：大数据下网络该如何监控？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/19"><span>18 | 耗电优化（上）：从电量优化的演进看耗电分析</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/20"><span>19 | 耗电优化（下）：耗电的优化方法与线上监控</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/21"><span>20 | UI 优化（上）：UI 渲染的几个关键概念</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/22"><span>21 | UI 优化（下）：如何优化 UI 渲染？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/23"><span>22 | 包体积优化（上）：如何减少安装包大小？</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/24"><span>23 | 包体积优化（下）：资源优化的进阶实践</span></a></li><li><a href="/blog-front/android开发高手课/03.模块一高质量开发/25"><span>24 | 想成为Android高手，你需要先搞定这三个问题</span></a></li></ul></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发">04.模块二高效开发</a><ul><li><a href="/blog-front/android开发高手课/04.模块二高效开发/01"><span>25 | 如何提升组织与个人的研发效能？</span></a></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发/02"><span>26 | 关于编译，你需要了解什么？</span></a></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发/03"><span>27 | 编译插桩的三种方法：AspectJ、ASM、ReDex</span></a></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发/04"><span>28 | 大数据与AI，如何高效地测试？</span></a></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发/05"><span>29 | 从每月到每天，如何给版本发布提速？</span></a></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发/06"><span>30 | 数据评估（上）：如何实现高可用的上报组件？</span></a></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发/07"><span>31 | 数据评估（下）：什么是大数据平台？</span></a></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发/08"><span>32 | 线上疑难问题该如何排查和跟踪？</span></a></li><li><a href="/blog-front/android开发高手课/04.模块二高效开发/09"><span>33 | 做一名有高度的移动开发工程师</span></a></li></ul></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进">05.模块三架构演进</a><ul><li><a href="/blog-front/android开发高手课/05.模块三架构演进/01"><span>34 | 聊聊重构：优秀的架构都是演进而来的</span></a></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进/02"><span>35 | Native Hook 技术，天使还是魔鬼？</span></a></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进/03"><span>36 | 跨平台开发的现状与应用</span></a></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进/04"><span>37 | 移动开发新大陆：工作三年半，移动开发转型手游开发</span></a></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进/05"><span>38 | 移动开发新大陆：Android音视频开发</span></a></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进/06"><span>39 | 移动开发新大陆： 边缘智能计算的趋势</span></a></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进/07"><span>40 | 动态化实践，如何选择适合自己的方案？</span></a></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进/08"><span>41 | 聊聊Flutter，面对层出不穷的新技术该如何跟进？</span></a></li><li><a href="/blog-front/android开发高手课/05.模块三架构演进/09"><span>42 | Android开发高手课学习心得</span></a></li></ul></li><li><a href="/blog-front/android开发高手课/06.练习sample跑起来">06.练习Sample跑起来</a><ul><li><a href="/blog-front/android开发高手课/06.练习sample跑起来/01"><span>练习Sample跑起来 | 热点问题答疑第1期</span></a></li><li><a href="/blog-front/android开发高手课/06.练习sample跑起来/02"><span>练习Sample跑起来 | 热点问题答疑第2期</span></a></li><li><a href="/blog-front/android开发高手课/06.练习sample跑起来/03"><span>练习Sample跑起来 | 热点问题答疑第3期</span></a></li><li><a href="/blog-front/android开发高手课/06.练习sample跑起来/04"><span>练习Sample跑起来 | 热点问题答疑第4期</span></a></li><li><a href="/blog-front/android开发高手课/06.练习sample跑起来/05"><span>练习Sample跑起来 | ASM插桩强化练习</span></a></li><li><a href="/blog-front/android开发高手课/06.练习sample跑起来/06"><span>练习Sample跑起来 | 唯鹿同学的练习手记 第1辑</span></a></li><li><a href="/blog-front/android开发高手课/06.练习sample跑起来/07"><span>练习Sample跑起来 | 唯鹿同学的练习手记 第2辑</span></a></li><li><a href="/blog-front/android开发高手课/06.练习sample跑起来/08"><span>练习Sample跑起来 | 唯鹿同学的练习手记 第3辑</span></a></li></ul></li><li><a href="/blog-front/android开发高手课/07.特别放送">07.特别放送</a><ul><li><a href="/blog-front/android开发高手课/07.特别放送/01"><span>Android JVM TI机制详解（内含福利彩蛋）</span></a></li><li><a href="/blog-front/android开发高手课/07.特别放送/02"><span>专栏学得苦？可能是方法没找对</span></a></li><li><a href="/blog-front/android开发高手课/07.特别放送/03"><span>专栏学得苦？可能你还需要一份配套学习书单</span></a></li><li><a href="/blog-front/android开发高手课/07.特别放送/04"><span>Native下如何获取调用栈？</span></a></li><li><a href="/blog-front/android开发高手课/07.特别放送/05"><span>聊聊Framework的学习方法</span></a></li><li><a href="/blog-front/android开发高手课/07.特别放送/06"><span>Android工程师的“面试指南”</span></a></li><li><a href="/blog-front/android开发高手课/07.特别放送/07"><span>程序员修炼之路 | 设计能力的提升途径</span></a></li></ul></li><li><a href="/blog-front/android开发高手课/08.结束语">08.结束语</a><ul><li><a href="/blog-front/android开发高手课/08.结束语/01"><span>结束语 | 移动开发的今天和明天</span></a></li><li><a href="/blog-front/android开发高手课/08.结束语/02"><span>结课测试 | 这些Android知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-front/android开发高手课/summary">android开发高手课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="SQLite的那些事儿" data-depth="2"><a href="/blog-front/android开发高手课/03.模块一高质量开发/15#sqlite的那些事儿"><span>SQLite的那些事儿</span></a></li><li title="SQLite的其他特性" data-depth="2"><a href="/blog-front/android开发高手课/03.模块一高质量开发/15#sqlite的其他特性"><span>SQLite的其他特性</span></a></li><li title="SQLite的监控" data-depth="2"><a href="/blog-front/android开发高手课/03.模块一高质量开发/15#sqlite的监控"><span>SQLite的监控</span></a></li><li title="总结" data-depth="2"><a href="/blog-front/android开发高手课/03.模块一高质量开发/15#总结"><span>总结</span></a></li><li title="课后作业" data-depth="2"><a href="/blog-front/android开发高手课/03.模块一高质量开发/15#课后作业"><span>课后作业</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="14--存储优化下数据库sqlite的使用和优化"><a aria-hidden="true" tabindex="-1" href="/blog-front/android开发高手课/03.模块一高质量开发/15#14--存储优化下数据库sqlite的使用和优化"><span class="icon icon-link"></span></a>14 | 存储优化（下）：数据库SQLite的使用和优化</h1><p>我们先来复习一下前面讲到的存储方法的使用场景：少量的Key Value数据可以直接使用SharedPreferences，稍微复杂一些的数据类型也可以通过序列化成JSON或者Protocol Buffers保存，并且在开发中获取或者修改数据也很简单。</p><p>不过这几种方法可以覆盖所有的存储场景吗？数据量在几百上千条这个量级时它们的性能还可以接受，但如果是几万条的微信聊天记录呢？而且如何实现快速地对某几个联系人的数据做增删改查呢？</p><p>对于大数据的存储场景，我们需要考虑稳定性、性能和<strong>可扩展性</strong>，这个时候就要轮到今天的“主角”数据库登场了。讲存储优化一定绕不开数据库，而数据库这个主题又非常大，我也知道不少同学学数据库的过程是从入门到放弃。那么考虑到我们大多是从事移动开发的工作，今天我就来讲讲移动端数据库SQLite的使用和优化。</p><h2 id="sqlite的那些事儿"><a aria-hidden="true" tabindex="-1" href="/blog-front/android开发高手课/03.模块一高质量开发/15#sqlite的那些事儿"><span class="icon icon-link"></span></a>SQLite的那些事儿</h2><p>虽然市面上有很多的数据库，但受限于库体积和存储空间，适合移动端使用的还真不多。当然使用最广泛的还是我们今天的主角SQLite，但同样还是有一些其他不错的选择，例如创业团队的<a target="_blank" rel="noopener noreferrer" href="https://github.com/realm/realm-java">Realm<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、Google的<a target="_blank" rel="noopener noreferrer" href="https://github.com/google/leveldb">LevelDB<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>等。</p><p>在国内那么多的移动团队中，微信对SQLite的研究可以算是最深入的。这其实是业务诉求导向的，用户聊天记录只会在本地保存，一旦出现数据损坏或者丢失，对用户来说都是不可挽回的。另一方面，微信有很大一批的重度用户，他们有几千个联系人、几千个群聊天，曾经做过一个统计，有几百万用户的数据库竟然大于1GB。对于这批用户，如何保证他们可以正常地使用微信是一个非常大的挑战。</p><p>所以当时微信专门开展了一个重度用户优化的专项。一开始的时候我们集中在SQLite使用上的优化，例如表结构、索引等。但很快就发现由于系统版本的不同，SQLite的实现也有所差异，经常会出现一些兼容性问题，并且也考虑到加密的诉求，我们决定单独引入自己的SQLite版本。</p><p>“源码在手，天下我有”，从此开启了一条研究数据库的“不归路”。那时我们投入了几个人专门去深入研究SQLite的源码，从SQLite的PRAGMA编译选项、<a target="_blank" rel="noopener noreferrer" href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286603&amp;idx=1&amp;sn=d243dd27f2c6614631241cd00570e853&amp;chksm=8334c349b4434a5fd81809d656bfad6072f075d098cb5663a85823e94fc2363edd28758ab882&amp;mpshare=1&amp;scene=1&amp;srcid=0609GLAeaGGmI4zCHTc2U9ZX#rd">Cursor实现优化<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，到SQLite源码的优化，最后打造出从实验室到线上的整个监控体系。</p><p>在2017年，我们开源了内部使用的SQLite数据库<a target="_blank" rel="noopener noreferrer" href="https://github.com/Tencent/wcdb/wiki">WCDB<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。这里多说两句，看一个开源项目是否靠谱，就看这个项目对产品本身有多重要。微信开源坚持内部与外部使用同一个版本，虽然我现在已经离开了微信团队，但还是欢迎有需要的同学使用WCDB。</p><p>在开始学习前我要提醒你，SQLite的优化同样也很难通过一两篇文章就把每个细节都讲清楚。今天的内容我选择了一些比较重要的知识点，并且为你准备了大量的参考资料，遇到陌生或者不懂的地方需要结合参考资料反复学习。</p><p><strong>1. ORM</strong></p><p>坦白说可能很多BAT的高级开发工程师都不完全了解SQLite的内部机制，也不能正确地写出高效的SQL语句。大部分应用为了提高开发效率，会引入ORM框架。ORM（Object Relational Mapping）也就是对象关系映射，用面向对象的概念把数据库中表和对象关联起来，可以让我们不用关心数据库底层的实现。</p><p>Android中最常用的ORM框架有开源<a target="_blank" rel="noopener noreferrer" href="https://github.com/greenrobot/greenDAO">greenDAO<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和Google官方的<a target="_blank" rel="noopener noreferrer" href="https://developer.android.com/training/data-storage/room/">Room<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，那使用ORM框架会带来什么问题呢？</p><p>使用ORM框架真的非常简单，但是简易性是需要牺牲部分执行效率为代价的，具体的损耗跟ORM框架写得好不好很有关系。但可能更大的问题是让很多的开发者的思维固化，最后可能连简单的SQL语句都不会写了。</p><p>那我们的应用是否应该引入ORM框架呢？可能程序员天生追求偷懒，为了提高开发效率，应用的确应该引入ORM框架。<strong>但是这不能是我们可以不去学习数据库基础知识的理由，只有理解底层的一些机制，我们才能更加得心应手地解决疑难的问题</strong>。</p><p>考虑到可以更好的与Android Jetpack的组件互动，<a target="_blank" rel="noopener noreferrer" href="https://github.com/Tencent/wcdb/wiki/Android-WCDB-%E4%BD%BF%E7%94%A8-Room-ORM-%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A">WCDB选择Room作为ORM框架<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p><strong>2. 进程与线程并发</strong></p><p>如果我们在项目中有使用SQLite，那么下面这个<a target="_blank" rel="noopener noreferrer" href="https://developer.android.com/reference/android/database/sqlite/SQLiteDatabaseLockedException">SQLiteDatabaseLockedException<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>就是经常会出现的一个问题。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">android.database.sqlite.SQLiteDatabaseLockedException: database is locked</span></div><div class="token-line"><span class="token plain">      at android.database.sqlite.SQLiteDatabase.dbopen</span></div><div class="token-line"><span class="token plain">      at android.database.sqlite.SQLiteDatabase.openDatabase</span></div><div class="token-line"><span class="token plain">      at android.database.sqlite.SQLiteDatabase.openDatabase</span></div></pre></div><p>SQLiteDatabaseLockedException归根到底是因为并发导致，而SQLite的并发有两个维度，一个是多进程并发，一个是多线程并发。下面我们分别来讲一下它们的关键点。</p><p><strong>多进程并发</strong></p><p>SQLite默认是支持多进程并发操作的，它通过文件锁来控制多进程的并发。SQLite锁的粒度并没有非常细，它针对的是整个DB文件，内部有5个状态，具体你可以参考下面的文章。</p><ul><li><p>官方文档：<a target="_blank" rel="noopener noreferrer" href="https://www.sqlite.org/lockingv3.html">SQLite locking<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p>SQLite源码分析：<a target="_blank" rel="noopener noreferrer" href="http://huili.github.io/lockandimplement/machining.html">SQLite锁机制简介<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://www.cnblogs.com/cchust/p/4761814.html">SQLite封锁机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li></ul><p>简单来说，多进程可以同时获取SHARED锁来读取数据，但是只有一个进程可以获取EXCLUSIVE锁来写数据库。对于iOS来说可能没有多进程访问数据库的场景，可以把locking_mode的默认值改为EXCLUSIVE。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">PRAGMA locking_mode = EXCLUSIVE</span></div></pre></div><p>在EXCLUSIVE模式下，数据库连接在断开前都不会释放SQLite文件的锁，从而避免不必要的冲突，提高数据库访问的速度。</p><p><strong>多线程并发</strong></p><p>相比多进程，多线程的数据库访问可能会更加常见。SQLite支持多线程并发模式，需要开启下面的配置，当然系统SQLite会默认开启多线程<a target="_blank" rel="noopener noreferrer" href="https://sqlite.org/threadsafe.html">Multi-thread模式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">PRAGMA SQLITE_THREADSAFE = 2</span></div></pre></div><p><strong>跟多进程的锁机制一样，为了实现简单，SQLite锁的粒度都是数据库文件级别，并没有实现表级甚至行级的锁</strong>。还有需要说明的是，<strong>同一个句柄同一时间只有一个线程在操作</strong>，这个时候我们需要打开连接池Connection Pool。</p><p>如果使用WCDB在初始化的时候可以指定连接池的大小，在微信中我们设置的大小是4。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public static SQLiteDatabase openDatabase (String path, </span></div><div class="token-line"><span class="token plain">                        SQLiteDatabase.CursorFactory factory, </span></div><div class="token-line"><span class="token plain">                        int flags, </span></div><div class="token-line"><span class="token plain">                        DatabaseErrorHandler errorHandler, </span></div><div class="token-line"><span class="token plain">                        int poolSize)</span></div></pre></div><p>跟多进程类似，多线程可以同时读取数据库数据，但是写数据库依然是互斥的。SQLite提供了Busy Retry的方案，即发生阻塞时会触发Busy Handler，此时可以让线程休眠一段时间后，重新尝试操作，你可以参考<a target="_blank" rel="noopener noreferrer" href="https://mp.weixin.qq.com/s/8FjDqPtXWWqOInsiV79Chg">《微信iOS SQLite源码优化实践》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>这篇文章。</p><p>为了进一步提高并发性能，我们还可以打开<a target="_blank" rel="noopener noreferrer" href="https://www.sqlite.org/wal.html">WAL<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（Write-Ahead Logging）模式。WAL模式会将修改的数据单独写到一个WAL文件中，同时也会引入了WAL日志文件锁。通过WAL模式读和写可以完全地并发执行，不会互相阻塞。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">PRAGMA schema.journal_mode = WAL</span></div></pre></div><p><strong>但是需要注意的是，写之间是仍然不能并发</strong>。如果出现多个写并发的情况，依然有可能会出现SQLiteDatabaseLockedException。这个时候我们可以让应用中捕获这个异常，然后等待一段时间再重试。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">} catch (SQLiteDatabaseLockedException e) {</span></div><div class="token-line"><span class="token plain">        if (sqliteLockedExceptionTimes &lt; (tryTimes - 1)) {</span></div><div class="token-line"><span class="token plain">            try {</span></div><div class="token-line"><span class="token plain">                Thread.sleep(100);</span></div><div class="token-line"><span class="token plain">            } catch (InterruptedException e1) {</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        sqliteLockedExceptionTimes++；</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><strong>总的来说通过连接池与WAL模式，我们可以很大程度上增加SQLite的读写并发，大大减少由于并发导致的等待耗时，建议大家在应用中可以尝试开启。</strong></p><p><strong>3. 查询优化</strong></p><p>说到数据库的查询优化，你第一个想到的肯定是建索引，那我就先来讲讲SQLite的索引优化。</p><p><strong>索引优化</strong></p><p>正确使用索引在大部分的场景可以大大降低查询速度，微信的数据库优化也是通过索引开始。下面是索引使用非常简单的一个例子，我们先从索引表找到数据对应的rowid，然后再从原数据表直接通过rowid查询结果。</p><p><img src="/blog-front/static/httpsstatic001geekbangorgresourceimage57d957fd28e1464b7ffbb1ba2b5379b84ad9.deff5348.gif" alt=""/></p><p>关于SQLite索引的原理网上有很多文章，在这里我推荐一些参考资料给你：</p><ul><li><p><a target="_blank" rel="noopener noreferrer" href="https://www.cnblogs.com/huahuahu/p/sqlite-suo-yin-de-yuan-li-ji-ying-yong.html">SQLite索引的原理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p>官方文档：<a target="_blank" rel="noopener noreferrer" href="https://www.sqlite.org/queryplanner.html#searching">Query Planning<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li></ul><p>这里的关键在于如何正确的建立索引，很多时候我们以为已经建立了索引，但事实上并没有真正生效。例如使用了BETWEEN、LIKE、OR这些操作符、使用表达式或者case when等。更详细的规则可参考官方文档<a target="_blank" rel="noopener noreferrer" href="http://www.sqlite.org/optoverview.html">The SQLite Query Optimizer Overview<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，下面是一个通过优化转换达到使用索引目的的例子。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">BETWEEN：myfiedl索引无法生效</span></div><div class="token-line"><span class="token plain">    SELECT * FROM mytable WHERE myfield BETWEEN 10 and 20;</span></div><div class="token-line"><span class="token plain">    转换成：myfiedl索引可以生效</span></div><div class="token-line"><span class="token plain">    SELECT * FROM mytable WHERE myfield &gt;= 10 AND myfield &lt;= 20;</span></div></pre></div><p>建立索引是有代价的，需要一直维护索引表的更新。比如对于一个很小的表来说就没必要建索引；如果一个表经常是执行插入更新操作，那么也需要节制的建立索引。总的来说有几个原则：</p><ul><li><p>建立正确的索引。这里不仅需要确保索引在查询中真正生效，我们还希望可以选择最高效的索引。如果一个表建立太多的索引，那么在查询的时候SQLite可能不会选择最好的来执行。</p></li><li><p>单列索引、多列索引与复合索引的选择。索引要综合数据表中不同的查询与排序语句一起考虑，如果查询结果集过大，还是希望可以通过复合索引直接在索引表返回查询结果。</p></li><li><p>索引字段的选择。整型类型索引效率会远高于字符串索引，而对于主键SQLite会默认帮我们建立索引，所以主键尽量不要用复杂字段。</p></li></ul><p><strong>总的来说索引优化是SQLite优化中最简单同时也是最有效的，但是它并不是简单的建一个索引就可以了，有的时候我们需要进一步调整查询语句甚至是表的结构，这样才能达到最好的效果。</strong></p><p><strong>页大小与缓存大小</strong></p><p>在I/O文件系统中，我讲过数据库就像一个小文件系统一样，事实上它内部也有页和缓存的概念。</p><p>对于SQLite的DB文件来说，页（page）是最小的存储单位，如下图所示每个表对应的数据在整个DB文件中都是通过一个一个的页存储，属于同一个表不同的页以B树（B-tree）的方式组织索引，每一个表都是一棵B树。</p><p><img src="/blog-front/static/httpsstatic001geekbangorgresourceimagec9f3c9b494da11233c98f2a54abfe2921ef3.a5241d0b.png" alt=""/></p><p>跟文件系统的页缓存（Page Cache）一样，SQLite会将读过的页缓存起来，用来加快下一次读取速度。页大小默认是1024Byte，缓存大小默认是1000页。更多的编译参数你可以查看官方文档<a target="_blank" rel="noopener noreferrer" href="https://sqlite.org/pragma.html#pragma_journal_mode">PRAGMA Statements<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">PRAGMA page_size = 1024</span></div><div class="token-line"><span class="token plain">    PRAGMA cache_size = 1000</span></div></pre></div><p>每个页永远只存放一个表或者一组索引的数据，即不可能同一个页存放多个表或索引的数据，表在整个DB文件的第一个页就是这棵B树的根页。继续以上图为例，如果想查询rowID为N+2的数据，我们首先要从sqlite_master查找出table的root page的位置，然后读取root page、page4这两个页，所以一共会需要3次I/O。</p><p><img src="/blog-front/static/httpsstatic001geekbangorgresourceimagef21cf232cbaff34236a1933182a02c685a1c.f4158b89.png" alt=""/></p><p>从上表可以看到，增大page size并不能不断地提升性能，在拐点以后可能还会有副作用。我们可以通过PRAGMA改变默认page size的大小，也可以再创建DB文件的时候进行设置。但是需要注意如果存在老的数据，需要调用vacuum对数据表对应的节点重新计算分配大小。</p><p>在微信的内部测试中，如果使用4KB的page size性能提升可以在5%～10%。但是考虑到历史数据的迁移成本，最终还是使用1024Byte。<strong>所以这里建议大家在新建数据库的时候，就提前选择4KB作为默认的page size以获得更好的性能。</strong></p><p><strong>其他优化</strong></p><p>关于SQLite的使用优化还有很多很多，下面我简单提几个点。</p><ul><li><p>慎用“<code>select*</code>”，需要使用多少列，就选取多少列。</p></li><li><p>正确地使用事务。</p></li><li><p>预编译与参数绑定，缓存被编译后的SQL语句。</p></li><li><p>对于blob或超大的Text列，可能会超出一个页的大小，导致出现超大页。建议将这些列单独拆表，或者放到表字段的后面。</p></li><li><p>定期整理或者清理无用或可删除的数据，例如朋友圈数据库会删除比较久远的数据，如果用户访问到这部分数据，重新从网络拉取即可。</p></li></ul><p>在日常的开发中，我们都应该对这些知识有所了解，再来复习一下上面学到的SQLite优化方法。<strong>通过引进ORM，可以大大的提升我们的开发效率。通过WAL模式和连接池，可以提高SQLite的并发性能。通过正确的建立索引，可以提升SQLite的查询速度。通过调整默认的页大小和缓存大小，可以提升SQLite的整体性能。</strong></p><h2 id="sqlite的其他特性"><a aria-hidden="true" tabindex="-1" href="/blog-front/android开发高手课/03.模块一高质量开发/15#sqlite的其他特性"><span class="icon icon-link"></span></a>SQLite的其他特性</h2><p>除了SQLite的优化经验，我在微信的工作中还积累了很多使用的经验，下面我挑选了几个比较重要的经验把它分享给你。</p><p><strong>1. 损坏与恢复</strong></p><p>微信中SQLite的损耗率在1/20000～1/10000左右，虽然看起来很低，不过意考虑到微信的体量，这个问题还是不容忽视的。特别是如果某些大佬的聊天记录丢失，我们团队都会承受超大的压力。</p><p>创新是为了解决焦虑，技术都是逼出来的。对于SQLite损坏与恢复的研究，可以说是微信投入比较大的一块。关于SQLite数据库的损耗与修复，以及微信在这里的优化成果，你可以参考下面这些资料。</p><ul><li><p><a target="_blank" rel="noopener noreferrer" href="https://sqlite.org/howtocorrupt.html">How To Corrupt An SQLite Database File<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://mp.weixin.qq.com/s/N1tuHTyg3xVfbaSd4du-tw">微信 SQLite 数据库修复实践<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://mp.weixin.qq.com/s/Ln7kNOn3zx589ACmn5ESQA">微信移动端数据库组件WCDB系列（二） — 数据库修复三板斧<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/Tencent/wcdb/wiki/Android%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%AE%E5%A4%8D">WCDB Android数据库修复<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li></ul><p><strong>2. 加密与安全</strong></p><p>数据库的安全主要有两个方面，一个是防注入，一个是加密。防注入可以通过静态安全扫描的方式，而加密一般会使用SQLCipher支持。</p><p>SQLite的加解密都是以页为单位，默认会使用AES算法加密，加/解密的耗时跟选用的密钥长度有关。下面是<a target="_blank" rel="noopener noreferrer" href="https://github.com/Tencent/wcdb/wiki/Android-Benchmark">WCDB Android Benchmark<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的数据，详细的信息请查看链接里的说明，从结论来说对Create来说影响会高达到10倍。</p><p><img src="/blog-front/static/httpsstatic001geekbangorgresourceimage5f815f5ac545e346a45f1c3fcfa504300b81.a305ca43.png" alt=""/></p><p>关于WCDB加解密的使用，你可以参考<a target="_blank" rel="noopener noreferrer" href="https://mp.weixin.qq.com/s/NFnYEXSxAaHBqpi7WofSPQ">《微信移动数据库组件WCDB（四） — Android 特性篇》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p><strong>3. 全文搜索</strong></p><p>微信的全文搜索也是一个技术导向的项目，最开始的时候性能并不是很理想，经常会被人“批斗”。经过几个版本的优化迭代，目前看效果还是非常不错的。</p><p><img src="/blog-front/static/httpsstatic001geekbangorgresourceimaged2d9d2a09d040d0d915e78d7598457d6d1d9.15e92f9c.png" alt=""/></p><p>关于全文搜索，你可以参考这些资料：</p><ul><li><p><a target="_blank" rel="noopener noreferrer" href="https://sqlite.org/fts3.html">SQLite FTS3 and FTS4 Extensions<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://mp.weixin.qq.com/s/AhYECT3HVyn1ikB0YQ-UVg">微信全文搜索优化之路<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://mp.weixin.qq.com/s/GCznwCtjJ2XUszyMcbNz8Q">移动客户端多音字搜索<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li></ul><p><strong>关于SQLite的这些特性，我们需要根据自己的项目情况综合考虑。假如某个数据库存储的数据并不重要，这个时候万分之一的数据损坏率我们并不会关心。同样是否需要使用数据库加密，也要根据存储的数据是不是敏感内容。</strong></p><h2 id="sqlite的监控"><a aria-hidden="true" tabindex="-1" href="/blog-front/android开发高手课/03.模块一高质量开发/15#sqlite的监控"><span class="icon icon-link"></span></a>SQLite的监控</h2><p>首先我想说，正确使用索引，正确使用事务。对于大型项目来说，参与的开发人员可能有几十几百人，开发人员水平参差不齐，很难保证每个人都可以正确而高效地使用SQLite，所以这次时候需要建立完善的监控体系。</p><p><strong>1. 本地测试</strong></p><p>作为一名靠谱的开发工程师，我们每写一个SQL语句，都应该先在本地测试。我们可以通过 EXPLAIN QUERY PLAN测试SQL语句的查询计划，是全表扫描还是使用了索引，以及具体使用了哪个索引等。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sqlite&gt; EXPLAIN QUERY PLAN SELECT * FROM t1 WHERE a=1 AND b&gt;2;</span></div><div class="token-line"><span class="token plain">    QUERY PLAN</span></div><div class="token-line"><span class="token plain">    |--SEARCH TABLE t1 USING INDEX i2 (a=? AND b&gt;?)</span></div></pre></div><p>关于SQLite命令行与EXPLAIN QUERY PLAN的使用，可以参考<a target="_blank" rel="noopener noreferrer" href="https://sqlite.org/cli.html">Command Line Shell For SQLite<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>以及<a target="_blank" rel="noopener noreferrer" href="https://sqlite.org/eqp.html">EXPLAIN QUERY PLAN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p><strong>2. 耗时监控</strong></p><p>本地测试过于依赖开发人员的自觉性，所以很多时候我们依然需要建立线上大数据的监控。因为微信集成了自己的SQLite源码，所以可以非常方便地增加自己想要的监控模块。</p><p>WCDB增加了<a target="_blank" rel="noopener noreferrer" href="https://tencent.github.io/wcdb/references/android/reference/com/tencent/wcdb/database/SQLiteTrace.html">SQLiteTrace<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的监控模块，有以下三个接口：</p><p><img src="/blog-front/static/httpsstatic001geekbangorgresourceimagef38af3f0b4b43e4911dc0655694fca90358a.97223ac0.png" alt=""/></p><p>我们可以通过这些接口监控数据库busy、损耗以及执行耗时。针对耗时比较长的SQL语句，需要进一步检查是SQL语句写得不好，还是需要建立索引。</p><p><img src="/blog-front/static/httpsstatic001geekbangorgresourceimage125d12c3d1b494fc4fb60fa0a429a8ff805d.51382af9.png" alt=""/></p><p><strong>3. 智能监控</strong></p><p>对于查询结果的监控只是我们监控演进的第二阶段，在这个阶段我们依然需要人工介入分析，而且需要比较有经验的人员负责。</p><p>我们希望SQL语句的分析可以做到智能化，是完全不需要门槛的。微信开源的Matrix里面就有一个智能化分析SQLite语句的工具：<a target="_blank" rel="noopener noreferrer" href="https://mp.weixin.qq.com/s/laUgOmAcMiZIOfM2sWrQgw">Matrix SQLiteLint – SQLite 使用质量检测<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。<strong>它根据分析SQL语句的语法树，结合我们日常数据库使用的经验，抽象出索引使用不当、<code>select*</code>等六大问题。</strong></p><p><img src="/blog-front/static/httpsstatic001geekbangorgresourceimagea481a40411af3c91c9d58cac27f4f53aaa81.d3b6738f.png" alt=""/></p><p>可能有同学会感叹为什么微信的人可以想到这样的方式，事实上这个思路在MySQL中是非常常见的做法。美团也开源了它们内部的SQL优化工具SQLAdvisor，你可以参考这些资料：</p><ul><li><p><a target="_blank" rel="noopener noreferrer" href="https://tech.meituan.com/SQL_parser_used_in_mtdp.html">SQL解析在美团的应用<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://tech.meituan.com/sqladvisor_pr.html">美团点评SQL优化工具SQLAdvisor开源<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li></ul><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-front/android开发高手课/03.模块一高质量开发/15#总结"><span class="icon icon-link"></span></a>总结</h2><p>数据库存储是一个开发人员的基本功，清楚SQLite的底层机制对我们的工作会有很大的指导意义。</p><p>掌握了SQLite数据库并发的机制，在某些时候我们可以更好地决策应该拆数据表还是拆数据库。新建一个数据库好处是可以隔离其他库并发或者损坏的情况，而坏处是数据库初始化耗时以及更多内存的占用。一般来说，单独的业务都会使用独立数据库，例如专门的下载数据库、朋友圈数据库、聊天数据库。但是数据库也不宜太多，我们可以有一个公共数据库，用来存放一些相对不是太大的数据。</p><p>在了解SQLite数据库损坏的原理和概率以后，我们可以根据数据的重要程度决定是否要引入恢复机制。我还讲了如何实现数据库加密以及对性能的影响，我们可以根据数据的敏感程度决定是否要引入加密。</p><p>最后我再强调一下，SQLite优化真的是一个很大的话题，在课后你还需要结合参考资料再进一步反复学习，才能把今天的内容理解透彻。</p><h2 id="课后作业"><a aria-hidden="true" tabindex="-1" href="/blog-front/android开发高手课/03.模块一高质量开发/15#课后作业"><span class="icon icon-link"></span></a>课后作业</h2><p>在你的应用中是否使用数据库存储呢，使用了哪种数据库？是否使用ORM？在使用数据库过程中你有哪些疑问或者经验呢？欢迎留言跟我和其他同学一起讨论。</p><p>如果你的应用也在使用SQLite存储，今天的课后练习是尝试接入WCDB，对比测试系统默认SQLite的性能。尝试接入<a target="_blank" rel="noopener noreferrer" href="https://github.com/Tencent/matrix/tree/master/matrix/matrix-android/matrix-sqlite-lint">Matrix SQLiteLint<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，查看是否存在不合理的SQLite使用。</p><p>除了今天文章中的参考资料，我还给希望进阶的同学准备了下面的资料，欢迎有兴趣的同学继续深入学习。</p><ul><li><p><a target="_blank" rel="noopener noreferrer" href="https://sqlite.org/docs.html">SQLite官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="http://huili.github.io/sqlite/sqliteintro.html">SQLite源码分析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/AndroidAdvanceWithGeektime/Chapter14/blob/master/%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90SQLite.pdf">全面解析SQLite<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p>图书《SQLite权威指南（第2版）》</p></li></ul><p>欢迎你点击“请朋友读”，把今天的内容分享给好友，邀请他一起学习。最后别忘了在评论区提交今天的作业，我也为认真完成作业的同学准备了丰厚的“学习加油礼包”，期待与你一起切磋进步哦。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/android开发高手课/03.模块一高质量开发/15.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 20:50:39</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-front/umi.js"></script>
  </body>
</html>
