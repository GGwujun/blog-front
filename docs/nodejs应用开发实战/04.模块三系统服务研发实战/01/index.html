<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>15 | 理论先行：高并发设计必须学的知识点有哪些？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/nodejs应用开发实战/04.模块三系统服务研发实战/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础</span><span>算法<ul><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a aria-current="page" class="active" href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackchain">webpackchain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>移动端开发<ul><li><a href="/blog/android开发高手课">android开发高手课</a></li><li><a href="/blog/ios开发高手课">ios开发高手课</a></li></ul></span><span>软件测试</span><span>产品与用户体验<ul><li><a href="/blog/视觉笔记入门课">视觉笔记入门课</a></li></ul></span><span>面试</span><span>杂谈<ul><li><a href="/blog/git实战手册">git实战手册</a></li><li><a href="/blog/nodejs">nodejs</a></li><li><a href="/blog/reactjs">reactjs</a></li><li><a href="/blog/ui设计">ui设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础</li><li>算法<ul><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a aria-current="page" class="active" href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackchain">webpackchain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>移动端开发<ul><li><a href="/blog/android开发高手课">android开发高手课</a></li><li><a href="/blog/ios开发高手课">ios开发高手课</a></li></ul></li><li>软件测试</li><li>产品与用户体验<ul><li><a href="/blog/视觉笔记入门课">视觉笔记入门课</a></li></ul></li><li>面试</li><li>杂谈<ul><li><a href="/blog/git实战手册">git实战手册</a></li><li><a href="/blog/nodejs">nodejs</a></li><li><a href="/blog/reactjs">reactjs</a></li><li><a href="/blog/ui设计">ui设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/nodejs/01.koa">01.Koa</a><ul><li><a href="/blog/nodejs/01.koa/01"><span>深入koa源码：核心库原理</span></a></li><li><a href="/blog/nodejs/01.koa/02"><span>深入koa源码：架构设计</span></a></li><li><a href="/blog/nodejs/01.koa/03"><span>深入koa源码：手动实现玩具版koa</span></a></li></ul></li><li><a href="/blog/nodejs/02.命令行">02.命令行</a><ul><li><a href="/blog/nodejs/02.命令行/01"><span>玩转 Nodejs 命令行</span></a></li></ul></li><li><a href="/blog/nodejs/03.测试">03.测试</a><ul><li><a href="/blog/nodejs/03.测试/01"><span>Jest实战：单元测试与服务测试</span></a></li><li><a href="/blog/nodejs/03.测试/02"><span>Jest进阶：接入ts、集成测试与覆盖率统计</span></a></li></ul></li><li><a href="/blog/nodejs/04.serverless">04.Serverless</a><ul><li><a href="/blog/nodejs/04.serverless/01"><span>基于实时数据库：在线对战五子棋小游戏</span></a></li><li><a href="/blog/nodejs/04.serverless/02"><span>基于ServerLess的极简网页计数器：源码分析与最佳实践</span></a></li></ul></li><li><a href="/blog/nodejs/05.更多">05.更多</a><ul><li><a href="/blog/nodejs/05.更多/01"><span>NodeJS实现简易区块链</span></a></li><li><a href="/blog/nodejs/05.更多/02"><span>负载均衡：轮询调度算法实现</span></a></li><li><a href="/blog/nodejs/05.更多/03"><span>VemoJS源码拆解</span></a></li><li><a href="/blog/nodejs/05.更多/04"><span>NodeJS是如何监听文件的变化？</span></a></li><li><a href="/blog/nodejs/05.更多/05"><span>日志库的实现机制与优化方法</span></a></li></ul></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="知识回顾" data-depth="3"><a href="/blog/nodejs应用开发实战/04.模块三系统服务研发实战/01#知识回顾"><span>知识回顾</span></a></li><li title="高并发知识" data-depth="3"><a href="/blog/nodejs应用开发实战/04.模块三系统服务研发实战/01#高并发知识"><span>高并发知识</span></a></li><li title="总结" data-depth="3"><a href="/blog/nodejs应用开发实战/04.模块三系统服务研发实战/01#总结"><span>总结</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="15--理论先行高并发设计必须学的知识点有哪些"><a aria-hidden="true" tabindex="-1" href="/blog/nodejs应用开发实战/04.模块三系统服务研发实战/01#15--理论先行高并发设计必须学的知识点有哪些"><span class="icon icon-link"></span></a>15 | 理论先行：高并发设计必须学的知识点有哪些？</h1><p>前面几讲我们学习的性能相关的知识点，都是基于单个接口或者单个服务，从这一讲开始，我们将从系统层面设计高并发的系统，所以掌握单个接口技术性能相关的知识远远不够，你还要拓展更多的知识点，比如服务器内核配置、单机单服务部署和多机多服务部署、多机器负载均衡策略以及如何做并行压测等。</p><p>那么今天，我就先带你回顾一下前面第 1、6、7、8 和 9 讲的设计要点，然后在此基础上，带你学习一些需要进一步实践的相关知识。</p><h3 id="知识回顾"><a aria-hidden="true" tabindex="-1" href="/blog/nodejs应用开发实战/04.模块三系统服务研发实战/01#知识回顾"><span class="icon icon-link"></span></a>知识回顾</h3><p>对于单个服务或者单个接口，我们学习了在 Node.js 中要着重注意的 5 个高性能点。</p><ol><li><p>主线程避阻塞，特别是一些复杂 CPU 密集计算型，最好的方式是交由其他进程处理，减少当前服务进程的阻塞；</p></li><li><p>多进程 cluster 模式的应用，充分利用多核服务器，能够在单台机器启用多个进程进行负载均衡，提升服务的稳定性；</p></li><li><p>在 I/O 方面要注重缓存的应用，本地缓存优先、其次共享内存、最后再是数据库（能用本地缓存的尽量用，不能用本地缓存的考虑共享内存，如果共享内存也不行，那么就需要使用数据库，而数据库可以优先考虑 MongoDB 内存查询效率更高的数据库，最后再考虑 MySQL，如果遇到必须查询或者写 MySQL 时，可以用延迟队列方式）；</p></li><li><p>过载保护策略，提升服务的稳定性，在服务过载时，保住部分用户的请求链路，以免影响所有用户；</p></li><li><p>工具自动化，单接口单服务性能保证，在上线前至少保证代码没有性能异常问题。</p></li></ol><p>以上是我们之前学习的一部分知识，其中会涉及应用细节，比如在缓存方面我们不仅仅要考虑缓存数据，还应该考虑存储过期的问题；又比如过载保护，什么样的过载参数适合我们当前服务，这些都需要你进行实践应用，去沉淀和总结。</p><h3 id="高并发知识"><a aria-hidden="true" tabindex="-1" href="/blog/nodejs应用开发实战/04.模块三系统服务研发实战/01#高并发知识"><span class="icon icon-link"></span></a>高并发知识</h3><p>除了上述知识点，我认为你还需要掌握以下 5 个关键的知识点：</p><ol><li><p>微服务拆分、独立系统、可扩展、可分流；</p></li><li><p>机器内核网络配置；</p></li><li><p>单机单服务和单机多服务；</p></li><li><p>多机器部署负载均衡；</p></li><li><p>并行压测。</p></li></ol><p>接下来我带你学习每个技术点的核心部分。</p><h4 id="微服务拆分"><a aria-hidden="true" tabindex="-1" href="/blog/nodejs应用开发实战/04.模块三系统服务研发实战/01#微服务拆分"><span class="icon icon-link"></span></a>微服务拆分</h4><p>微服务拆分要分阶段来进行，在项目初期，微服务拆分建议在项目中去进行，其核心是 Controller 、 Model 以及 Service 的代码按项目区分，比如可以按照下面这种方式。</p><p><img src="/images/nodejs%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/04.%E6%A8%A1%E5%9D%97%E4%B8%89%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/iimage6M0139F2Cgp9HWB9TpyAJjg1AABwcxUmgzs211.png" alt="Drawing 0.png"/></p><div data-nodeid="1454"><p style="text-align:center">图 1 项目拆分方式</p></div><p>在项目初期，流量并发并不高，该方式比较好维护，但随着项目流量以及功能越来越多，就应该考虑微服务拆分。主要是按照业务功能进行拆分（这里你要注意，基础服务模块在 Node.js 中最好不要拆分为服务，而应该拆分为模块，模块调用的方式肯定比网路性能更高）。</p><p>在业务功能较复杂时，拆分出独立的项目有这样几个好处：</p><ol><li><p>便于扩展和后期维护；</p></li><li><p>能够独立部署，针对流量不同的业务，独立安排部署；</p></li><li><p>功能解藕、服务安全、减少相互影响，避免一个业务承载压力过大，导致所有服务异常；</p></li><li><p>多人协作开发模式清晰，可以按照功能模块进行团队人力划分，这样既清晰又便于团队合作管理；</p></li></ol><p>既然有这些优点，那么我们应该如何去做微服务拆分呢？</p><p>最简单的方式，就是将图 1 中的模块按照文件模块进行拆分，其他保持不变。假设 user 模块流量较大，那么我们就需要单独拆分这个模块到一个项目，其他的部分我们复制一份。</p><p>上面这种方式固然是比较简单的，但是问题来了，我们很多基础模块都复制了一份，以后怎么去维护，项目越多发现维护成本会越来越高，那么有没有更好的方式来处理呢？</p><p>我们需要将通用的部分进行整合，然后不同的部分进行拆分，比如上面的项目结构，可以拆分出这样的结构。</p><p><img src="/images/nodejs%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/04.%E6%A8%A1%E5%9D%97%E4%B8%89%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/iimage6M0139F2Cgp9HWB9TqSALKcMAACWOU_LikA525.png" alt="Drawing 1.png"/></p><div data-nodeid="1471"><p style="text-align:center">图 2 拆分方式</p></div><p>图 2 中 common 为我们公共部分，main 为流量较小项目，user 则为一个独立的比较大流量的模块，这样就可以做到单独拆分并且公用。现网发布时，如果发布的是 user 服务，则只发布 common 和 user，如果发布 main 服务，则只发布 common 和 main。这样就可以做到既复用又独立的方式。</p><p>当然微服务拆分也会让开发者的开发模式更为复杂，团队协作沟通成本更高。</p><h4 id="机器内核网络配置"><a aria-hidden="true" tabindex="-1" href="/blog/nodejs应用开发实战/04.模块三系统服务研发实战/01#机器内核网络配置"><span class="icon icon-link"></span></a>机器内核网络配置</h4><p>微服务拆分是基于一种框架的解决方案，能降低耦合提升单个服务的处理能力，但不能实质性的提升整体服务的并发处理能力，而服务器内核的网络配置却在一定程度上可以提升并发处理能力。关于机器内核网络配置，这里会涉及几个比较关键的内核配置（请注意，一般情况下请勿修改内核配置，要修改也请运维比较专业的人员进行配置）。</p><p>我们来看下调优 TCP 相关的一些参数。具体配置在 /etc/sysctl.conf 文件中，或者也可以创建新配置文件，比如 /etc/sysctl.d/99-tuning.conf ，然后运行sysctl -p，让内核装载这个配置。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">net.ipv4.ip_local_port_range=&#x27;1024 65000&#x27;</span></div><div class="token-line"><span class="token plain">    net.ipv4.tcp_tw_reuse=&#x27;1&#x27;</span></div><div class="token-line"><span class="token plain">    net.ipv4.tcp_fin_timeout=&#x27;15&#x27;</span></div><div class="token-line"><span class="token plain">    net.core.netdev_max_backlog=&#x27;4096&#x27;</span></div><div class="token-line"><span class="token plain">    net.core.rmem_max=&#x27;16777216&#x27;</span></div><div class="token-line"><span class="token plain">    net.core.somaxconn=&#x27;4096&#x27;</span></div><div class="token-line"><span class="token plain">    net.core.wmem_max=&#x27;16777216&#x27;</span></div><div class="token-line"><span class="token plain">    net.ipv4.tcp_max_syn_backlog=&#x27;20480&#x27;</span></div><div class="token-line"><span class="token plain">    net.ipv4.tcp_max_tw_buckets=&#x27;400000&#x27;</span></div><div class="token-line"><span class="token plain">    net.ipv4.tcp_no_metrics_save=&#x27;1&#x27;</span></div><div class="token-line"><span class="token plain">    net.ipv4.tcp_rmem=&#x27;4096 87380 16777216&#x27;</span></div><div class="token-line"><span class="token plain">    net.ipv4.tcp_syn_retries=&#x27;2&#x27;</span></div><div class="token-line"><span class="token plain">    net.ipv4.tcp_synack_retries=&#x27;2&#x27;</span></div><div class="token-line"><span class="token plain">    net.ipv4.tcp_wmem=&#x27;4096 65536 16777216&#x27;</span></div><div class="token-line"><span class="token plain">    vm.min_free_kbytes=&#x27;65536&#x27;</span></div></pre></div><p>这里重点说下几个配置。</p><ul><li><p><strong>ip_local_port_range：</strong> 如果在请求高并发时，会导致端口不够用，因此需要调整范围，但是你要注意，范围并不是越小越好，如果从 1024 开始，也可能会与系统相关的进程服务端口冲突，从而导致请求失败。</p></li><li><p><strong>net.ipv4.tcp_tw_reuse：</strong> 当服务器要在大量 TCP 连接之间切换时，会产生大量处于TIME_WAIT 状态的连接。TIME_WAIT意味着连接本身是关闭的，但资源没有释放，将net_ipv4_tcp_tw_reuse 设置为 1 是让内核在安全时尽量回收连接，这比重新建立新连接便宜得多。</p></li><li><p><strong>net.ipv4.tcp_fin_timeout：</strong> 这是处于 TIME_WAIT状态的连接在回收前必须等待的最小时间，改小它可以加快回收，当然也不是越小越好，如果太小比如设置5，可能会导致 TCP 连接异常。</p></li></ul><p>如果需要对其他的配置进行改动，希望大家在改动前大家先深入去了解 Linux 内核参数的作用，它的改动范围以及所带来的影响面，这部分改动如果出现问题，可能会出现一些难以定位的现网问题。</p><h4 id="单机单服务和单机多服务"><a aria-hidden="true" tabindex="-1" href="/blog/nodejs应用开发实战/04.模块三系统服务研发实战/01#单机单服务和单机多服务"><span class="icon icon-link"></span></a>单机单服务和单机多服务</h4><p>Node.js 服务在部署时，需要分 2 种情况：</p><ul><li><p>单机只部署一个 Node.js 服务；</p></li><li><p>单机上部署多个 Node.js 服务。</p></li></ul><p>我们分别看一下这两者需要注意的细节。</p><p><strong>单机单服务</strong></p><p>单机单服务适合并发较大、功能底层的服务，比如Node.js 做业务网关时，就适合单机单服务。因为网关并发一般较大，需要非常严谨地了解当前承担的并发和性能。而单机单服务则可以非常精准的了解性能数据，不会被外界因素干扰。</p><p>在应用这种服务时，你要按照机器核数来启用进程数，等于或者小于核数（最好是小于核数），避免在并发较高时，占满 CPU ，从而影响机器性能，系统资源无法调度，那样就非常危险。</p><p><strong>单机多服务</strong></p><p>单机多服务适合于多个业务服务，但这多个业务并发相对不高，比如应用 Node.js 做一些活动或者通用中台服务时。该情况不利于判断当前服务启用的进程数，需要根据具体的业务判断。</p><p>假设我们在一台 16 核机器上部署 2 个服务，一个并发较高，一个并发较低，但是两者经过分析，并发高的 10 核就可以满足到要求，而并发低的只需要 4 核就足够。这种情况就不会有太大的风险，因为加起来 14 核，也不会影响到性能问题。但两者加起来如果超出 16 核，比如并发低的需要 8 核才能满足业务，就要考虑两者在什么场景下是否存在同时并发的压力，如果存在并发压力就应该考虑将两者分到不同机器上，而不是同一台机器上，或者增加机器来满足当前业务场景。</p><p>如果一台机器上有 4 个服务呢？分析方法还是和上面相似，按照以下几个步骤来评判。</p><ol><li><p>判断 4 个服务加起来是否超出当前 CPU 总核数；</p></li><li><p>不超出不会有影响，超出时则判断多个服务是否会在同时最大并发数，或者最大并发的服务加起来是否会超出当前 CPU 核数；</p></li><li><p>多个服务最大并发不会超出 CPU 核数时，则可以合并部署；</p></li><li><p>多个服务最大并发会超出 CPU 核数时，就需要考虑拆分服务出去，或者增加机器，减少 CPU 核数占用，比如原来是 6 核 2 台机器，现在增加了 2 台机器，可以 3 核 4 台机器，虽然这种方法计算不够准确，但是可以这样参考。</p></li></ol><p>实际开发过程中监控和性能告警是非常重要的，当 CPU 长期处于高负荷时，一定是需要告警的，我们才能知道是否需要进一步扩容或者性能优化提升。</p><h4 id="多机器部署负载均衡"><a aria-hidden="true" tabindex="-1" href="/blog/nodejs应用开发实战/04.模块三系统服务研发实战/01#多机器部署负载均衡"><span class="icon icon-link"></span></a>多机器部署负载均衡</h4><p>上面我介绍的是单机注意的细节，接下来我们再来看一下多机器的负载均衡方案。后台服务一般都有个独立 IP:PORT ，如果有域名，一般会选择用 Nginx 作为负载均衡的服务，没有域名的话，多个服务之间调用。多服务之间调用，就需要使用到一个叫作名字服务的功能，该功能主要是使用方可以通过一个字符串名字，随机获取一个可用的 IP:PORT 配置；</p><p><img src="/images/nodejs%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/04.%E6%A8%A1%E5%9D%97%E4%B8%89%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/iimage6M0139F2Cgp9HWB9Tx6AUefLAADCvjmrv30935.png" alt="Drawing 2.png"/></p><div data-nodeid="1515"><p style="text-align:center">图 3 负载均衡方法</p></div><p>图 3 就是一个负载均衡的方案，对于域名访问按照刚才所说可以使用 Nginx，而对于服务间调用则使用名字服务。这种方案，可以适配我们现在的绝大不多数后台多服务的负载均衡方案，因此对于 Node.js 来说，我们实际开发中负载均衡也是使用这套方案。</p><h4 id="并行压测"><a aria-hidden="true" tabindex="-1" href="/blog/nodejs应用开发实战/04.模块三系统服务研发实战/01#并行压测"><span class="icon icon-link"></span></a>并行压测</h4><p>如果我们服务使用了刚才上面所介绍的多服务负载均衡的方案，那么我们就需要去学习一种新的方案来评估服务承载能力。接下来我们就来学习一下，怎么有效地评估服务承载的情况。</p><p><strong>1</strong>. 首先应用 clinicjs 压测工具，检测单个接口是否存在性能问题；</p><p><strong>2</strong>. 计算当前服务所应该承担的最大并发情况，我们用一个渐进性的表格来分析，如表格 1。</p><p><img src="/images/nodejs%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/04.%E6%A8%A1%E5%9D%97%E4%B8%89%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/iimage6M003A65CioPOWB_g7eAJW_sAABOZsdm58g189.png" alt="image.png"/></p><div data-nodeid="1543"><p style="text-align:center">表格 1 预测并发压力方式</p></div><p>比如我们当前 DAU 1000 万，最高在线人数 12% ，因此最高的在线人数 120 万，而按照秒来计算的话，我们用当前数除以 60 就是每秒，但是由于不是严格除以 60 ，我们需要乘以 5 来确保安全，最后 10% 的在线用户会使用到该服务，所以该服务最大并发数是 1万 QPS。</p><p>假设我们有 4 台服务器，按照平均分配的话，那么每台机器处理并发数大概是 2500 的 QPS 。</p><p>得到 1 万的结论后，我们再细分接口的并发数，得到一个像表格 2 的结论。</p><p><img src="/images/nodejs%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/04.%E6%A8%A1%E5%9D%97%E4%B8%89%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/iimage6M003A65CioPOWB_g8CAIJSsAABEY3NwObM047.png" alt="image (1).png"/></p><div data-nodeid="1569"><p style="text-align:center">表格 2 并发结论</p></div><p><strong>3</strong>. 拿到表格 2 结论后，就可以联合的压测以上 4 个接口了，分别按照 1000 、200 、1000 和 300 的并发去压测；</p><p><strong>4</strong>. 压测后就可以得出当前服务的情况，接下来就需要进行多台机器联合压测，在现网一般情况下是无法 4 台同时摘除压测的，可以考虑在现网比较空闲的时段，使用 2 台进行压测进一步分析是否满足要求；</p><p><strong>5</strong>. 如果单台机器涉及多服务，那么则需要将多个服务进行联合压测，才能真实的得到现网的负载承受能力。</p><p>这里就不详细的实践压测细节了，压测这部分还需要你自己多进行学习和深入掌握。</p><h3 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/nodejs应用开发实战/04.模块三系统服务研发实战/01#总结"><span class="icon icon-link"></span></a>总结</h3><p>总的来说，这一讲也是我之前使用 Node.js 开发沉淀下来的一些经验，你在学习本讲时，着重了解这些知识点即可，在实际应用过程中再来逐个参考，我这里所介绍的也是一个参考项，真正实际应用过程中还需要你和项目组的同事一起讨论。</p><p>这一讲，我提到了并行压测，今天的作业就是：希望你应用 wrk 来实现一个联合压测工具，可行的话可以在评论区分享给后面的同学。下一讲我们将实现一个通用的透传类的 Node.js 服务，也就是一个简单版本的业务网关服务。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/nodejs应用开发实战/04.模块三系统服务研发实战/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 14:44:16</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
